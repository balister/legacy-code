diff -Naur u-boot-1.1.6/Makefile u-boot-1.1.6_davinci/Makefile
--- u-boot-1.1.6/Makefile	2006-11-02 15:15:01.000000000 +0100
+++ u-boot-1.1.6_davinci/Makefile	2006-11-27 13:45:30.000000000 +0100
@@ -125,7 +125,7 @@
 CROSS_COMPILE = powerpc-linux-
 endif
 ifeq ($(ARCH),arm)
-CROSS_COMPILE = arm-linux-
+CROSS_COMPILE = arm_v5t_le-
 endif
 ifeq ($(ARCH),i386)
 ifeq ($(HOSTARCH),i386)
@@ -1827,6 +1827,9 @@
 	fi
 	@$(MKCONFIG) -a netstar arm arm925t netstar
 
+davinci_config :    unconfig
+	@./mkconfig $(@:_config=) arm arm926ejs davinci
+
 omap1510inn_config :	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm925t omap1510inn
 
diff -Naur u-boot-1.1.6/board/davinci/Makefile u-boot-1.1.6_davinci/board/davinci/Makefile
--- u-boot-1.1.6/board/davinci/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.6_davinci/board/davinci/Makefile	2007-03-08 14:09:30.000000000 +0100
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000, 2001, 2002
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= lib$(BOARD).a
+
+OBJS	:= davinci.o timer.o dm644x_emac.o
+SOBJS	:= platform.o
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) crv $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+.depend:	Makefile $(SOBJS:.o=.S) $(OBJS:.o=.c)
+		$(CC) -M $(CPPFLAGS) $(SOBJS:.o=.S) $(OBJS:.o=.c) > $@
+
+-include .depend
+
+#########################################################################
diff -Naur u-boot-1.1.6/board/davinci/config.mk u-boot-1.1.6_davinci/board/davinci/config.mk
--- u-boot-1.1.6/board/davinci/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.6_davinci/board/davinci/config.mk	2006-11-27 13:45:30.000000000 +0100
@@ -0,0 +1,26 @@
+#
+# (C) Copyright 2002
+# Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+# David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+#
+# (C) Copyright 2003
+# Texas Instruments, <www.ti.com>
+# Swaminathan <swami.iyer@ti.com>
+#
+# Davinci EVM board (ARM925EJS) cpu
+# see http://www.ti.com/ for more information on Texas Instruments
+#
+# Davinci EVM has 1 bank of 256 MB DDR RAM 
+# Physical Address:
+# 8000'0000 to 9000'0000
+#
+#
+# Linux-Kernel is expected to be at 8000'8000, entry 8000'8000
+# (mem base + reserved)
+#
+# we load ourself to 8100 '0000
+#
+#
+
+#Provide a atleast 16MB spacing between us and the Linux Kernel image
+TEXT_BASE = 0x81080000
diff -Naur u-boot-1.1.6/board/davinci/davinci.c u-boot-1.1.6_davinci/board/davinci/davinci.c
--- u-boot-1.1.6/board/davinci/davinci.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.6_davinci/board/davinci/davinci.c	2007-03-07 15:09:53.000000000 +0100
@@ -0,0 +1,356 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ Modifications:
+ ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+
+#include <common.h>
+#include <i2c.h>
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+#include <linux/mtd/nand.h>
+extern struct nand_chip nand_dev_desc[CFG_MAX_NAND_DEVICE];
+#endif
+
+#if 0
+void flash__init (void);
+void ether__init (void);
+#endif
+#define PLL1_PLLM   *(volatile unsigned int *)0x01c40910
+#define PLL2_PLLM   *(volatile unsigned int *)0x01c40D10
+#define PLL2_DIV2   *(volatile unsigned char *)0x01c40D1C
+
+void davinci_psc_all_enable(void);
+
+/*******************************************
+ Routine: delay
+ Description:  Delay function
+*******************************************/
+static inline void delay (unsigned long loops)
+{
+	       __asm__ volatile ("1:\n"
+		     "subs %0, %1, #1\n"
+		     "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*******************************************
+ Routine: board_init
+ Description:  Board Initialization routine
+*******************************************/
+int board_init (void)
+{
+    	  DECLARE_GLOBAL_DATA_PTR;
+
+        /* arch number of DaVinci DVDP-Board */
+        gd->bd->bi_arch_number = 901;
+
+      	/* adress of boot parameters */
+       	gd->bd->bi_boot_params = LINUX_BOOT_PARAM_ADDR;
+        /* Configure MUX settings */
+
+      /* Power on required peripherals */
+    	davinci_psc_all_enable();
+#if 0
+      	/* this speeds up your boot a quite a bit.  However to make it
+ 	 *  work, you need make sure your kernel startup flush bug is fixed.
+	 *  ... rkw ...
+	 */
+	icache_enable ();
+#endif
+/*     	inittimer (); */
+      	return 0;
+}
+
+/* PSC Domains */
+#define LPSC_VPSSMSTR       0       // VPSS Master LPSC
+#define LPSC_VPSSSLV        1       // VPSS Slave LPSC
+#define LPSC_TPCC           2       // TPCC LPSC
+#define LPSC_TPTC0          3       // TPTC0 LPSC
+#define LPSC_TPTC1          4       // TPTC1 LPSC
+#define LPSC_EMAC           5       // EMAC LPSC
+#define LPSC_EMAC_WRAPPER   6       // EMAC WRAPPER LPSC
+#define LPSC_MDIO           7       // MDIO LPSC
+#define LPSC_IEEE1394       8       // IEEE1394 LPSC
+#define LPSC_USB            9       // USB LPSC
+#define LPSC_ATA            10      // ATA LPSC
+#define LPSC_VLYNQ          11      // VLYNQ LPSC
+#define LPSC_UHPI           12      // UHPI LPSC
+#define LPSC_DDR_EMIF       13      // DDR_EMIF LPSC
+#define LPSC_AEMIF          14      // AEMIF LPSC
+#define LPSC_MMC_SD         15      // MMC_SD LPSC
+#define LPSC_MEMSTICK       16      // MEMSTICK LPSC
+#define LPSC_McBSP          17      // McBSP LPSC
+#define LPSC_I2C            18      // I2C LPSC
+#define LPSC_UART0          19      // UART0 LPSC
+#define LPSC_UART1          20      // UART1 LPSC
+#define LPSC_UART2          21      // UART2 LPSC
+#define LPSC_SPI            22      // SPI LPSC
+#define LPSC_PWM0           23      // PWM0 LPSC
+#define LPSC_PWM1           24      // PWM1 LPSC
+#define LPSC_PWM2           25      // PWM2 LPSC
+#define LPSC_GPIO           26      // GPIO LPSC
+#define LPSC_TIMER0         27      // TIMER0 LPSC
+#define LPSC_TIMER1         28      // TIMER1 LPSC
+#define LPSC_TIMER2         29      // TIMER2 LPSC
+#define LPSC_SYSTEM_SUBSYS  30      // SYSTEM SUBSYSTEM LPSC
+#define LPSC_ARM            31      // ARM LPSC
+#define LPSC_SCR2           32      // SCR2 LPSC
+#define LPSC_SCR3           33      // SCR3 LPSC
+#define LPSC_SCR4           34      // SCR4 LPSC
+#define LPSC_CROSSBAR       35      // CROSSBAR LPSC
+#define LPSC_CFG27          36      // CFG27 LPSC
+#define LPSC_CFG3           37      // CFG3 LPSC
+#define LPSC_CFG5           38      // CFG5 LPSC
+#define LPSC_GEM            39      // GEM LPSC
+#define LPSC_IMCOP          40      // IMCOP LPSC
+
+#define EPCPR               *(( volatile unsigned int* )( 0x01C41070 ))
+#define PTCMD               *(( volatile unsigned int* )( 0x01C41120 ))
+#define PTSTAT              *(( volatile unsigned int* )( 0x01C41128 ))
+#define PDSTAT              *(( volatile unsigned int* )( 0x01C41200 ))
+#define PDSTAT1             *(( volatile unsigned int* )( 0x01C41204 ))
+#define PDCTL               *(( volatile unsigned int* )( 0x01C41300 ))
+#define PDCTL1              *(( volatile unsigned int* )( 0x01C41304 ))
+#define VBPR                *(( volatile unsigned int* )( 0x20000020 ))
+
+/**************************************
+ Routine: board_setup_psc_on
+ Description:  Enable a PSC domain
+**************************************/
+void board_setup_psc_on( unsigned int domain, unsigned int id )
+{
+        volatile unsigned int* mdstat = ( unsigned int* )( 0x01C41800 + 4 * id );
+	      volatile unsigned int* mdctl  = ( unsigned int* )( 0x01C41A00 + 4 * id );
+
+	      *mdctl |= 0x00000003; // Set PowerDomain to turn on
+
+    	  if ( ( PDSTAT & 0x00000001 ) == 0 )
+    	  {
+                PDCTL1 |= 0x1;
+        	      PTCMD = ( 1 << domain );
+        	      while ( ( ( ( EPCPR >> domain ) & 1 ) == 0 ) );
+
+        	      PDCTL1 |= 0x100 ;
+        	      while( ! ( ( ( PTSTAT >> domain ) & 1 ) == 0 ) );
+    	  }
+    	  else
+    	  {
+        	      PTCMD = ( 1<<domain );
+        	      while( ! ( ( ( PTSTAT >> domain ) & 1 ) == 0 ) );
+    	  }
+
+    	  while( ! ( ( *mdstat & 0x0000001F ) == 0x3 ) );
+}
+
+/**************************************
+ Routine: davinci_psc_all_enable
+ Description:  Enable all PSC domains
+**************************************/
+void davinci_psc_all_enable(void)
+{
+#define PSC_ADDR            0x01C41000
+
+        unsigned int alwaysOnPdNum = 0 ;
+
+    	  /* This function turns on all clocks in the ALWAYSON and DSP Power
+	       * Domains.  Note this function assumes that the Power Domains are
+	       * already on.
+	       */
+#if 0
+	unsigned int dspPdNum = 1, i;
+    	  /* Write ENABLE (0x3) to all 41 MDCTL[i].NEXT bit fields. */
+    	  for( i = 0; i < 41; i++){
+                *(volatile unsigned int*) (PSC_ADDR+0xA00+4*i) =
+				        *(volatile unsigned int*) (PSC_ADDR+0xA00+4*i) | 0x3;
+    	  }
+
+    	  /* For special workaround:  Set MDCTL[i].EMURSTIE to 0x1 for all of the
+	       * following Modules.  VPSSSLV, EMAC, EMACCTRL, MDIO, USB, ATA, VLYNQ,
+         * HPI, DDREMIF, AEMIF, MMCSD, MEMSTICK, ASP, GPIO, IMCOP.
+         */
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*1) = *(unsigned int*) (PSC_ADDR+0xA00+4*1) | 0x203;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*5) = *(unsigned int*) (PSC_ADDR+0xA00+4*5) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*6) = *(unsigned int*) (PSC_ADDR+0xA00+4*6) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*7) = *(unsigned int*) (PSC_ADDR+0xA00+4*7) | 0x203;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*9) = *(unsigned int*) (PSC_ADDR+0xA00+4*9) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*10) = *(unsigned int*) (PSC_ADDR+0xA00+4*10) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*11) = *(unsigned int*) (PSC_ADDR+0xA00+4*11) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*12) = *(unsigned int*) (PSC_ADDR+0xA00+4*12) | 0x203;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*13) = *(unsigned int*) (PSC_ADDR+0xA00+4*13) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*14) = *(unsigned int*) (PSC_ADDR+0xA00+4*14) | 0x203;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*15) = *(unsigned int*) (PSC_ADDR+0xA00+4*15) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*16) = *(unsigned int*) (PSC_ADDR+0xA00+4*16) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*17) = *(unsigned int*) (PSC_ADDR+0xA00+4*17) | 0x203;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*19) = *(unsigned int*) (PSC_ADDR+0xA00+4*19) | 0x203;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*26) = *(unsigned int*) (PSC_ADDR+0xA00+4*26) | 0x203;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*40) = *(unsigned int*) (PSC_ADDR+0xA00+4*40) | 0x203;*/
+#endif
+
+        /* For special workaround:  Clear MDCTL[i].EMURSTIE to 0x0 for all of the following Modules.
+         *  VPSSSLV, EMAC, EMACCTRL, MDIO, USB, ATA, VLYNQ,
+         *  HPI, DDREMIF, AEMIF, MMCSD, MEMSTICK, ASP, GPIO, IMCOP.
+         */
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*1) = *(unsigned int*) (PSC_ADDR+0xA00+4*1) & 0x003;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*5) = *(unsigned int*) (PSC_ADDR+0xA00+4*5) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*6) = *(unsigned int*) (PSC_ADDR+0xA00+4*6) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*7) = *(unsigned int*) (PSC_ADDR+0xA00+4*7) | 0x003;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*9) = *(unsigned int*) (PSC_ADDR+0xA00+4*9) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*10) = *(unsigned int*) (PSC_ADDR+0xA00+4*10) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*11) = *(unsigned int*) (PSC_ADDR+0xA00+4*11) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*12) = *(unsigned int*) (PSC_ADDR+0xA00+4*12) & 0x003;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*13) = *(unsigned int*) (PSC_ADDR+0xA00+4*13) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*14) = *(unsigned int*) (PSC_ADDR+0xA00+4*14) | 0x003;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*15) = *(unsigned int*) (PSC_ADDR+0xA00+4*15) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*16) = *(unsigned int*) (PSC_ADDR+0xA00+4*16) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*17) = *(unsigned int*) (PSC_ADDR+0xA00+4*17) & 0x003;*/
+        *(unsigned int*) (PSC_ADDR+0xA00+4*19) = *(unsigned int*) (PSC_ADDR+0xA00+4*19) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*18) = *(unsigned int*) (PSC_ADDR+0xA00+4*18) | 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*28) = *(unsigned int*) (PSC_ADDR+0xA00+4*28) | 0x003;
+        /**(unsigned int*) (PSC_ADDR+0xA00+4*26) = *(unsigned int*) (PSC_ADDR+0xA00+4*26) & 0x003;
+        *(unsigned int*) (PSC_ADDR+0xA00+4*40) = *(unsigned int*) (PSC_ADDR+0xA00+4*40) & 0x003;*/
+
+    	  /* Set PTCMD.GO0 to 0x1 to initiate the state transtion for Modules in
+	       * the ALWAYSON Power Domain
+	       */
+	PTCMD = (1<<alwaysOnPdNum);
+
+    	  /* Wait for PTSTAT.GOSTAT0 to clear to 0x0 */
+    	  while(! ((( PTSTAT >> alwaysOnPdNum) & 0x00000001) == 0));
+
+
+        /* Bringup UART out of reset here since NS16650 code that we are using from uBoot
+         * will not do it
+         */
+#define UARTPWREMU_MGMT     0x01c20030
+        *(volatile unsigned int*) UARTPWREMU_MGMT = 0x0000E003;
+        
+	/* Enable GIO3.3V cells used for EMAC */
+#define VDD3P3V_PWDN        0x01c40048
+        *(volatile unsigned int*) VDD3P3V_PWDN = 0;
+
+#define PINMUX0     0x01C40000
+#define PINMUX4     0x01C40004
+
+        /* Enable UART0 MUX lines */
+        *(volatile unsigned int *)PINMUX4 |= 1;
+        /* Enable EMAC and AEMIF pins */
+        *(volatile unsigned int*) PINMUX0 = 0x80000C1F;
+
+	/* Enable I2C pin Mux */
+        *(volatile unsigned int *)PINMUX4 |= (1 << 7);
+
+	/* Set the Bus Priority Register to appropriate value */
+	VBPR = 0x20;
+}
+
+/******************************
+ Routine: misc_init_r
+ Description:  Misc. init
+******************************/
+int misc_init_r (void)
+{
+	char temp[20];
+	char emac_read_addr [10] = { 0x7f, 0 } ;
+	int  i= 0;
+        int clk = 0;
+
+        clk = ((PLL2_PLLM + 1) * 27) / (PLL2_DIV2 + 1);
+
+        printf ("ARM Clock :- %dMHz\n", ((((PLL1_PLLM + 1) * 27 ) / 2)) );
+        printf ("DDR Clock :- %dMHz\n", (clk/2));
+
+#if 0 
+	i2c_write (0x50, 0x00, 1, emac_read_addr, 2);
+	i2c_read (0x50, 0x00, 1, emac_read_addr, 6);
+        temp[0] = (emac_read_addr[0] & 0xF0) >> 4;
+        temp[1] = (emac_read_addr[0] & 0x0F);
+        temp[2] = ':';
+        temp[3] = (emac_read_addr[1] & 0xF0) >> 4;
+        temp[4] = (emac_read_addr[1] & 0x0F);
+        temp[5] = ':';
+        temp[6] = (emac_read_addr[2] & 0xF0) >> 4;
+        temp[7] = (emac_read_addr[2] & 0x0F);
+        temp[8] = ':';
+        temp[9] = (emac_read_addr[3] & 0xF0) >> 4;
+        temp[10]= (emac_read_addr[3] & 0x0F);
+        temp[11]= ':';
+        temp[12]= (emac_read_addr[4] & 0xF0) >> 4;
+        temp[13]= (emac_read_addr[4] & 0x0F);
+        temp[14]= ':';
+        temp[15]= (emac_read_addr[5] & 0xF0) >> 4;
+        temp[16]= (emac_read_addr[5] & 0x0F);
+                                                                               
+        for (i = 0; i < 17; i++)
+        {
+        if (temp[i] == ':')
+                continue;
+        else if (temp[i] >= 0 && temp[i] <= 9)
+                temp[i] = temp[i] + 48;
+        else
+                temp[i] = temp[i] + 87;
+        }
+                   
+	temp [17] = 0;                                                            
+	if ((emac_read_addr [0] != 0xFF) ||
+	    (emac_read_addr [1] != 0xFF) ||	
+	    (emac_read_addr [2] != 0xFF) ||	
+	    (emac_read_addr [3] != 0xFF) ||	
+	    (emac_read_addr [4] != 0xFF) ||	
+	    (emac_read_addr [5] != 0xFF))
+	{ 
+		setenv ("ethaddr", temp);
+	}
+
+	i2c_read (0x39, 0x00, 1, &i, 1);	
+	setenv ("videostd", ((i  & 0x80)?"pal":"ntsc"));
+#else
+	setenv ("ethaddr", "00:0e:99:02:57:7a");
+#endif	
+        return (0);
+}
+
+/******************************
+ Routine: dram_init
+ Description:  Memory Info
+******************************/
+int dram_init (void)
+{
+        DECLARE_GLOBAL_DATA_PTR;
+
+	      gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	      gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+        return 0;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_NAND)
+void nand_init(void)
+{
+    extern flash_info_t flash_info[];
+
+
+    nand_probe(CFG_NAND_ADDR);
+    if (nand_dev_desc[0].ChipID != NAND_ChipID_UNKNOWN) {
+                print_size(nand_dev_desc[0].totlen, "\n");
+    }
+}
+#endif
+
diff -Naur u-boot-1.1.6/board/davinci/dm644x_emac.c u-boot-1.1.6_davinci/board/davinci/dm644x_emac.c
--- u-boot-1.1.6/board/davinci/dm644x_emac.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.6_davinci/board/davinci/dm644x_emac.c	2007-03-07 14:07:38.000000000 +0100
@@ -0,0 +1,493 @@
+/*
+ * dm644x_emac.c
+ *
+ * TI DaVinci (DM644X) EMAC peripheral driver source for DV-EVM
+ *
+ * Copyright (C) 2005 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ 
+ * Modifications:
+ * ver. 1.0: Sep 2005, Anant Gole - Created EMAC version for uBoot.
+ * ver  1.1: Nov 2005, Anant Gole - Extended the RX logic for multiple descriptors
+ *
+ */
+ 
+#include <common.h>
+#include <command.h>
+#include <net.h>
+#include "dm644x_emac.h"
+
+#ifdef CONFIG_DRIVER_TI_EMAC
+
+#if (CONFIG_COMMANDS & CFG_CMD_NET)
+
+unsigned int emac_dbg = 1;
+#define debug_emac(fmt,args...)	if (emac_dbg) printf (fmt ,##args)
+
+/* EMAC internal functions - called when eth_xxx functions are invoked by the kernel */
+static int emac_hw_init (void);
+static int emac_open (void);
+static int emac_close (void);
+static int emac_send_packet (volatile void *packet, int length);
+static int emac_rcv_packet (void);
+
+/* The driver can be entered at any of the following entry points */
+extern int eth_init (bd_t * bd);
+extern void eth_halt (void);
+extern int eth_rx (void);
+extern int eth_send (volatile void *packet, int length);
+
+int eth_hw_init (void)
+{
+    return emac_hw_init();
+}
+
+int eth_init (bd_t * bd)
+{
+    return emac_open ();
+}
+
+void eth_halt ()
+{
+    emac_close ();
+}
+
+int eth_send (volatile void *packet, int length)
+{
+    return emac_send_packet (packet, length);
+}
+
+int eth_rx ()
+{
+    return emac_rcv_packet ();
+}
+
+
+static char emac_mac_addr[] = { 0x00, 0x00, 0x5b, 0xee, 0xde, 0xad };
+
+/*
+ * This function must be called before emac_open() if you want to override
+ * the default mac address.
+ */
+
+void emac_set_mac_addr (const char *addr)
+{
+    int i;
+
+    for (i = 0; i < sizeof (emac_mac_addr); i++) {
+        emac_mac_addr[i] = addr[i];
+    }
+}
+
+/***************************
+ * EMAC Global variables
+ ***************************/ 
+ 
+/* EMAC Addresses */
+static volatile emac_regs* adap_emac = (emac_regs *) EMAC_BASE_ADDR;
+static volatile ewrap_regs* adap_ewrap = (ewrap_regs *) EMAC_WRAPPER_BASE_ADDR;
+static volatile mdio_regs* adap_mdio = (mdio_regs *) EMAC_MDIO_BASE_ADDR;
+
+/* EMAC descriptors */
+static volatile emac_desc *emac_rx_desc = (emac_desc *) (EMAC_WRAPPER_RAM_ADDR + EMAC_RX_DESC_BASE);
+static volatile emac_desc *emac_tx_desc = (emac_desc *) (EMAC_WRAPPER_RAM_ADDR + EMAC_TX_DESC_BASE);
+static volatile emac_desc *emac_rx_active_head = 0;
+static volatile emac_desc *emac_rx_active_tail = 0;
+static int emac_rx_queue_active = 0;
+
+/* EMAC link status */
+static int emac_link_status = 0; /* 0 = link down, 1 = link up */
+
+/* Receive packet buffers */
+static unsigned char emac_rx_buffers[EMAC_MAX_RX_BUFFERS * (EMAC_MAX_ETHERNET_PKT_SIZE + EMAC_PKT_ALIGN)];
+
+/* This function initializes the emac hardware */
+static int emac_hw_init (void)
+{
+    /* Enabling power and reset from outside the module is required */
+    return (0);
+}
+
+/* Read a PHY register via MDIO inteface */
+static int mdio_read(int phy_addr, int reg_num)
+{
+    adap_mdio->USERACCESS0 = MDIO_USERACCESS0_GO | MDIO_USERACCESS0_WRITE_READ | 
+                             ((reg_num & 0x1F) << 21) | 
+                             ((phy_addr & 0x1F) << 16);
+
+    /* Wait for command to complete */ 
+    while ((adap_mdio->USERACCESS0 & MDIO_USERACCESS0_GO) != 0);    
+
+    return (adap_mdio->USERACCESS0 & 0xFFFF);
+}
+
+/* Write to a PHY register via MDIO inteface */
+void mdio_write(int phy_addr, int reg_num, unsigned int data)
+{
+    /* Wait for User access register to be ready */
+    while ((adap_mdio->USERACCESS0 & MDIO_USERACCESS0_GO) != 0);    
+    
+    adap_mdio->USERACCESS0 = MDIO_USERACCESS0_GO | MDIO_USERACCESS0_WRITE_WRITE | 
+                             ((reg_num & 0x1F) << 21) | 
+                             ((phy_addr & 0x1F) << 16) |
+                             (data & 0xFFFF);
+}
+
+
+/* Get PHY link state - this function accepts a PHY mask for the caller to
+ * find out if any of the passed PHY addresses is connected
+ */
+int mdio_get_link_state(unsigned int phy_mask)
+{
+    unsigned int act_phy, phy_addr = 0, link_state = 0;
+    unsigned int config;
+
+    act_phy =  (adap_mdio->ALIVE & phy_mask);
+
+    debug_emac("act phy 0x%x\n", act_phy) ; 
+    
+    if (act_phy) 
+    {            
+        /* find the phy number */
+        while(act_phy) 
+        {
+            while(!(act_phy & 0x1)) 
+            {
+                phy_addr++; 
+                act_phy >>= 1;
+            }
+            /* Read the status register from PHY */
+            link_state = ((mdio_read(phy_addr, MII_STATUS_REG) & 0x4) >> 2);
+            if(link_state == 1) 
+            { 
+                /* The link can break off anytime, hence adding the fix for boosting the PHY signal
+                 * strength here so that everytime the link is found, this can be done and ensured
+                 * that we dont miss it
+                 */
+                 config = mdio_read(phy_addr, MII_DIGITAL_CONFIG_REG);
+                 config |= 0x800;
+                 mdio_write(phy_addr, MII_DIGITAL_CONFIG_REG, config);
+                 /* Read back to verify */
+                 config = mdio_read(phy_addr, MII_DIGITAL_CONFIG_REG);
+                 
+                break;
+            } 
+            else 
+            {
+                /* If no link, go to next phy. */                    
+                act_phy >>= 1;
+                phy_addr++;  
+            }
+        }
+    }
+    return link_state;    
+}
+
+/*
+ * The kernel calls this function when someone wants to use the device,
+ * typically 'ifconfig ethX up'.
+ */
+static int emac_open (void)
+{
+    volatile unsigned int *addr;
+    unsigned int clkdiv, cnt;
+    volatile emac_desc *rx_desc;
+    
+    debug_emac("+ emac_open\n");
+            
+    /* Reset EMAC module and disable interrupts in wrapper */
+    adap_emac->SOFTRESET = 1;
+    while (adap_emac->SOFTRESET != 0);
+    adap_ewrap->EWCTL = 0;
+    for (cnt=0; cnt < 5; cnt++) {
+        clkdiv = adap_ewrap->EWCTL;
+    }
+    
+    rx_desc = emac_rx_desc;
+
+    adap_emac->TXCONTROL = 0x1;
+    adap_emac->RXCONTROL = 0x1;
+        
+    /* Set MAC Addresses & Init multicast Hash to 0 (disable any multicast receive) */
+    /* Using channel 0 only - other channels are disabled */
+    adap_emac->MACINDEX = 0;
+    adap_emac->MACADDRHI = (emac_mac_addr[3] << 24) | (emac_mac_addr[2] << 16) |
+                            (emac_mac_addr[1] << 8)  | (emac_mac_addr[0]);
+    adap_emac->MACADDRLO = ((emac_mac_addr[5] << 8) | emac_mac_addr[4]);
+    
+    adap_emac->MACHASH1 = 0;
+    adap_emac->MACHASH2 = 0;
+    
+    /* Set source MAC address - REQUIRED */
+    adap_emac->MACSRCADDRHI = (emac_mac_addr[3] << 24) | (emac_mac_addr[2] << 16) |
+                              (emac_mac_addr[1] << 8)  | (emac_mac_addr[0]);
+    adap_emac->MACSRCADDRLO = ((emac_mac_addr[4] << 8) | emac_mac_addr[5]);
+    
+    /* Set DMA 8 TX / 8 RX Head pointers to 0 */
+    addr = &adap_emac->TX0HDP;
+    for( cnt=0; cnt<16; cnt++ )
+        *addr++ = 0;
+    addr = &adap_emac->RX0HDP;
+    for( cnt=0; cnt<16; cnt++ )
+        *addr++ = 0;
+
+    /* Clear Statistics (do this before setting MacControl register) */
+    addr = &adap_emac->RXGOODFRAMES;
+    for( cnt=0; cnt < EMAC_NUM_STATS; cnt++ )
+        *addr++ = 0;
+
+    /* No multicast addressing */
+    adap_emac->MACHASH1 = 0 ;
+    adap_emac->MACHASH2 = 0 ;
+    
+    /* Create RX queue and set receive process in place */
+    emac_rx_active_head = emac_rx_desc;
+    for (cnt=0; cnt < EMAC_MAX_RX_BUFFERS; cnt++)
+    {
+        rx_desc->next = (unsigned int) (rx_desc + 1);
+        rx_desc->buffer = &emac_rx_buffers[cnt * (EMAC_MAX_ETHERNET_PKT_SIZE + EMAC_PKT_ALIGN)];
+        rx_desc->buff_off_len = EMAC_MAX_ETHERNET_PKT_SIZE;
+        rx_desc->pkt_flag_len = EMAC_CPPI_OWNERSHIP_BIT;
+        ++rx_desc;
+    }
+    
+    /* Set the last descriptor's "next" parameter to 0 to end the RX desc list */
+    --rx_desc;
+    rx_desc->next = 0;
+    emac_rx_active_tail = rx_desc;
+    emac_rx_queue_active = 1;
+    
+    /* Enable TX/RX */
+    adap_emac->RXMAXLEN = EMAC_MAX_ETHERNET_PKT_SIZE;
+    adap_emac->RXBUFFEROFFSET = 0;
+    
+    /* No fancy configs - Use this for promiscous for debug - EMAC_RXMBPENABLE_RXCAFEN_ENABLE */
+    adap_emac->RXMBPENABLE = EMAC_RXMBPENABLE_RXBROADEN ;
+
+    /* Enable ch 0 only */
+    adap_emac->RXUNICASTSET = 0x1; 
+    
+    /* Enable MII interface and Full duplex mode */
+    adap_emac->MACCONTROL = (EMAC_MACCONTROL_MIIEN_ENABLE | EMAC_MACCONTROL_FULLDUPLEX_ENABLE); 
+    
+    /* Init MDIO & get link state */
+    clkdiv = (EMAC_MDIO_BUS_FREQ / EMAC_MDIO_CLOCK_FREQ) - 1;
+    adap_mdio->CONTROL = ((clkdiv & 0xFF) | MDIO_CONTROL_ENABLE | MDIO_CONTROL_FAULT);  
+    emac_link_status = mdio_get_link_state(EMAC_MDIO_PHY_MASK);
+    
+    /* Start receive process */
+    adap_emac->RX0HDP = (unsigned int) emac_rx_desc;
+    
+    debug_emac("- emac_open\n");
+
+    return (1);
+}
+
+/* EMAC Channel Teardown */
+void emac_ch_teardown(int ch)
+{
+    volatile unsigned int dly = 0xFF;
+    volatile unsigned int cnt;
+    
+    debug_emac("+ emac_ch_teardown\n");
+    
+    if (ch == EMAC_CH_TX)
+    {
+        /* Init TX channel teardown */
+        adap_emac->TXTEARDOWN = 1;
+        for( cnt = 0; cnt != 0xFFFFFFFC; cnt = adap_emac->TX0CP){
+            /* Wait here for Tx teardown completion interrupt to occur 
+             * Note: A task delay can be called here to pend rather than 
+             * occupying CPU cycles - anyway it has been found that teardown 
+             * takes very few cpu cycles and does not affect functionality */
+            --dly;
+            udelay(1);
+            if (dly == 0) break;
+        }
+        adap_emac->TX0CP = cnt;
+        adap_emac->TX0HDP = 0;
+    }
+    else
+    {
+        /* Init RX channel teardown */
+        adap_emac->RXTEARDOWN = 1;
+        for( cnt = 0; cnt != 0xFFFFFFFC; cnt = adap_emac->RX0CP){
+            /* Wait here for Tx teardown completion interrupt to occur 
+             * Note: A task delay can be called here to pend rather than 
+             * occupying CPU cycles - anyway it has been found that teardown 
+             * takes very few cpu cycles and does not affect functionality */
+            --dly;
+            udelay(1);
+            if (dly == 0) break;
+        }
+        adap_emac->RX0CP = cnt;
+        adap_emac->RX0HDP = 0;
+    }
+    
+    debug_emac("- emac_ch_teardown\n");
+}
+
+/*
+ * This is called by the kernel in response to 'ifconfig ethX down'.  It
+ * is responsible for cleaning up everything that the open routine
+ * does, and maybe putting the card into a powerdown state.
+ */
+static int emac_close (void)
+{
+    debug_emac("+ emac_close\n");
+    
+    emac_ch_teardown(EMAC_CH_TX); /* TX Channel teardown */
+    emac_ch_teardown(EMAC_CH_RX); /* RX Channel teardown */
+
+    /* Reset EMAC module and disable interrupts in wrapper */
+    adap_emac->SOFTRESET = 1;
+    adap_ewrap->EWCTL = 0;
+    
+    debug_emac("- emac_close\n");
+    return (1);
+}
+
+static int tx_send_loop = 0;
+
+/*
+ * This function sends a single packet on the network and returns
+ * positive number (number of bytes transmitted) or negative for error
+ */
+static int emac_send_packet (volatile void *packet, int length)
+{
+    int ret_status = -1;
+    tx_send_loop = 0;
+    
+    /* Return error if no link */
+    emac_link_status = mdio_get_link_state(EMAC_MDIO_PHY_MASK);
+    if (emac_link_status == 0)
+    {
+        printf("WARN: emac_send_packet: No link\n");
+        return (ret_status);
+    }
+    
+    /* Check packet size and if < EMAC_MIN_ETHERNET_PKT_SIZE, pad it up */
+    if (length < EMAC_MIN_ETHERNET_PKT_SIZE)
+    {
+      length = EMAC_MIN_ETHERNET_PKT_SIZE;
+    }
+
+    /* Populate the TX descriptor */
+    emac_tx_desc->next         = 0;
+    emac_tx_desc->buffer       = (unsigned char *)packet;
+    emac_tx_desc->buff_off_len = (length & 0xFFFF);
+    emac_tx_desc->pkt_flag_len = ((length & 0xFFFF) | 
+                                  EMAC_CPPI_SOP_BIT | 
+                                  EMAC_CPPI_OWNERSHIP_BIT | 
+                                  EMAC_CPPI_EOP_BIT);
+    /* Send the packet */
+    adap_emac->TX0HDP = (unsigned int) emac_tx_desc;
+    
+    /* Wait for packet to complete or link down */
+    while (1)
+    {
+        emac_link_status = mdio_get_link_state(EMAC_MDIO_PHY_MASK);
+        if (emac_link_status == 0)
+        {
+            emac_ch_teardown(EMAC_CH_TX);
+            return (ret_status);
+        }
+        if (adap_emac->TXINTSTATRAW & 0x1)
+        {
+            ret_status = length;
+            break;
+        }
+        ++tx_send_loop;
+    }
+
+    return (ret_status);
+    
+}
+
+/*
+ * This function handles receipt of a packet from the network
+ */
+static int emac_rcv_packet (void)
+{
+    volatile emac_desc *rx_curr_desc;
+    volatile emac_desc *curr_desc;
+    volatile emac_desc *tail_desc;
+    unsigned int status, ret= -1;
+    
+    rx_curr_desc = emac_rx_active_head;
+    status = rx_curr_desc->pkt_flag_len;
+    if ((rx_curr_desc) && ((status & EMAC_CPPI_OWNERSHIP_BIT) == 0))
+    {
+        if (status & EMAC_CPPI_RX_ERROR_FRAME) {
+            /* Error in packet - discard it and requeue desc */
+		    printf("WARN: emac_rcv_pkt: Error in packet\n");
+        }
+        else {
+            NetReceive(rx_curr_desc->buffer, (rx_curr_desc->buff_off_len & 0xFFFF));
+		    ret = rx_curr_desc->buff_off_len & 0xFFFF;
+        }
+
+        /* Ack received packet descriptor */
+        adap_emac->RX0CP = (unsigned int) rx_curr_desc;
+        curr_desc = rx_curr_desc;
+        emac_rx_active_head = rx_curr_desc->next;
+        
+        if (status & EMAC_CPPI_EOQ_BIT) {
+            if (emac_rx_active_head) {
+                adap_emac->RX0HDP = (unsigned int) emac_rx_active_head;
+            } else {
+                emac_rx_queue_active = 0;
+                printf("INFO:emac_rcv_packet: RX Queue not active\n");
+            }
+        }
+        
+        /* Recycle RX descriptor */        
+        rx_curr_desc->buff_off_len = EMAC_MAX_ETHERNET_PKT_SIZE;
+        rx_curr_desc->pkt_flag_len = EMAC_CPPI_OWNERSHIP_BIT;
+        rx_curr_desc->next = 0;
+
+        if (emac_rx_active_head == 0) {
+            printf("INFO: emac_rcv_pkt: active queue head = 0\n");
+            emac_rx_active_head = curr_desc;
+            emac_rx_active_tail = curr_desc;
+            if (emac_rx_queue_active != 0) {
+                adap_emac->RX0HDP = (unsigned int) emac_rx_active_head;
+                printf("INFO: emac_rcv_pkt: active queue head = 0, HDP fired\n");
+                emac_rx_queue_active = 1;
+            }
+        } else {
+
+            tail_desc = emac_rx_active_tail;
+            emac_rx_active_tail = curr_desc;
+            tail_desc->next = curr_desc;
+            status = tail_desc->pkt_flag_len;
+            if (status & EMAC_CPPI_EOQ_BIT) {
+                adap_emac->RX0HDP = (unsigned int) curr_desc;
+                status &= ~EMAC_CPPI_EOQ_BIT;
+                tail_desc->pkt_flag_len = status;
+            }
+        }   
+	    return ret;
+    }
+    return (0);
+}
+
+#endif /* CONFIG_COMMANDS & CFG_CMD_NET */
+
+#endif /* CONFIG_DRIVER_TI_EMAC */
diff -Naur u-boot-1.1.6/board/davinci/dm644x_emac.h u-boot-1.1.6_davinci/board/davinci/dm644x_emac.h
--- u-boot-1.1.6/board/davinci/dm644x_emac.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.6_davinci/board/davinci/dm644x_emac.h	2006-11-27 13:45:30.000000000 +0100
@@ -0,0 +1,290 @@
+/*
+ * dm644x_emac.h
+ *
+ * TI DaVinci (DM644X) EMAC peripheral driver header for DV-EVM
+ *
+ * Copyright (C) 2005 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ 
+ * Modifications:
+ * ver. 1.0: Sep 2005, TI PSP Team - Created EMAC version for uBoot.
+ *
+ */
+ 
+#ifndef _DM644X_EMAC_H_
+#define _DM644X_EMAC_H_
+
+/***********************************************
+ ********** Configurable items *****************
+ ***********************************************/
+ 
+/* Addresses of EMAC module in DaVinci */
+#define EMAC_BASE_ADDR             (0x01C80000)
+#define EMAC_WRAPPER_BASE_ADDR     (0x01C81000)
+#define EMAC_WRAPPER_RAM_ADDR      (0x01C82000)
+#define EMAC_MDIO_BASE_ADDR        (0x01C84000)
+
+/* MDIO module input frequency */
+#define EMAC_MDIO_BUS_FREQ          76500000    /* PLL/6 - 76.5 MHz */
+/* MDIO clock output frequency */
+#define EMAC_MDIO_CLOCK_FREQ        2200000     /* 2.2 MHz */
+
+/* PHY mask - set only those phy number bits where phy is/can be connected */
+#define EMAC_MDIO_PHY_MASK          0xFFFFFFFF
+
+/* Ethernet Min/Max packet size */
+#define EMAC_MIN_ETHERNET_PKT_SIZE  60
+#define EMAC_MAX_ETHERNET_PKT_SIZE  1518
+#define EMAC_PKT_ALIGN              18  /* 1518 + 18 = 1536 (packet aligned on 32 byte boundry) */
+
+/* Number of RX packet buffers
+ * NOTE: Only 1 buffer supported as of now 
+ */
+#define EMAC_MAX_RX_BUFFERS         10
+
+/***********************************************
+ ******** Internally used macros ***************
+ ***********************************************/
+
+#define EMAC_CH_TX                  1 
+#define EMAC_CH_RX                  0
+
+/* Each descriptor occupies 4, lets start RX desc's at 0 and 
+ * reserve space for 64 descriptors max
+ */
+#define EMAC_RX_DESC_BASE           0x0
+#define EMAC_TX_DESC_BASE           0x1000
+
+/* EMAC Teardown value */
+#define EMAC_TEARDOWN_VALUE         0xFFFFFFFC
+
+/* MII Status Register */
+#define MII_STATUS_REG              1
+
+/* Intel LXT971 Digtal Config Register */
+#define MII_DIGITAL_CONFIG_REG      26
+
+/* Number of statistics registers */
+#define EMAC_NUM_STATS              36
+
+/* EMAC Descriptor */
+typedef volatile struct _emac_desc 
+{
+  unsigned int      next;           /* Pointer to next descriptor in chain */
+  unsigned char     *buffer;        /* Pointer to data buffer              */
+  unsigned int      buff_off_len;   /* Buffer Offset(MSW) and Length(LSW)  */
+  unsigned int      pkt_flag_len;   /* Packet Flags(MSW) and Length(LSW)   */
+} emac_desc;
+
+/* CPPI bit positions */
+#define EMAC_CPPI_SOP_BIT               (0x80000000)  /*(1 << 31)*/
+#define EMAC_CPPI_EOP_BIT               (0x40000000)  /*(1 << 30*/
+#define EMAC_CPPI_OWNERSHIP_BIT         (0x20000000)  /*(1 << 29)*/
+#define EMAC_CPPI_EOQ_BIT               (0x10000000)  /*(1 << 28)*/
+#define EMAC_CPPI_TEARDOWN_COMPLETE_BIT (0x08000000)  /*(1 << 27)*/
+#define EMAC_CPPI_PASS_CRC_BIT          (0x04000000)  /*(1 << 26)*/
+
+#define EMAC_CPPI_RX_ERROR_FRAME        (0x03FC0000)
+
+#define EMAC_MACCONTROL_MIIEN_ENABLE        (0x20)
+#define EMAC_MACCONTROL_FULLDUPLEX_ENABLE   (0x1)
+
+#define EMAC_RXMBPENABLE_RXCAFEN_ENABLE     (0x200000)
+#define EMAC_RXMBPENABLE_RXBROADEN          (0x2000)
+
+
+#define MDIO_CONTROL_ENABLE             (0x40000000)
+#define MDIO_CONTROL_FAULT              (0x80000)
+#define MDIO_USERACCESS0_GO             (0x80000000)
+#define MDIO_USERACCESS0_WRITE_READ     (0x0)
+#define MDIO_USERACCESS0_WRITE_WRITE    (0x40000000)
+
+
+
+/* EMAC Register overlay */
+
+/* Ethernet MAC Register Overlay Structure */
+typedef volatile struct  {
+    unsigned int TXIDVER;
+    unsigned int TXCONTROL;
+    unsigned int TXTEARDOWN;
+    unsigned char RSVD0[4];
+    unsigned int RXIDVER;
+    unsigned int RXCONTROL;
+    unsigned int RXTEARDOWN;
+    unsigned char RSVD1[100];
+    unsigned int TXINTSTATRAW;
+    unsigned int TXINTSTATMASKED;
+    unsigned int TXINTMASKSET;
+    unsigned int TXINTMASKCLEAR;
+    unsigned int MACINVECTOR;
+    unsigned char RSVD2[12];
+    unsigned int RXINTSTATRAW;
+    unsigned int RXINTSTATMASKED;
+    unsigned int RXINTMASKSET;
+    unsigned int RXINTMASKCLEAR;
+    unsigned int MACINTSTATRAW;
+    unsigned int MACINTSTATMASKED;
+    unsigned int MACINTMASKSET;
+    unsigned int MACINTMASKCLEAR;
+    unsigned char RSVD3[64];
+    unsigned int RXMBPENABLE;
+    unsigned int RXUNICASTSET;
+    unsigned int RXUNICASTCLEAR;
+    unsigned int RXMAXLEN;
+    unsigned int RXBUFFEROFFSET;
+    unsigned int RXFILTERLOWTHRESH;
+    unsigned char RSVD4[8];
+    unsigned int RX0FLOWTHRESH;
+    unsigned int RX1FLOWTHRESH;
+    unsigned int RX2FLOWTHRESH;
+    unsigned int RX3FLOWTHRESH;
+    unsigned int RX4FLOWTHRESH;
+    unsigned int RX5FLOWTHRESH;
+    unsigned int RX6FLOWTHRESH;
+    unsigned int RX7FLOWTHRESH;
+    unsigned int RX0FREEBUFFER;
+    unsigned int RX1FREEBUFFER;
+    unsigned int RX2FREEBUFFER;
+    unsigned int RX3FREEBUFFER;
+    unsigned int RX4FREEBUFFER;
+    unsigned int RX5FREEBUFFER;
+    unsigned int RX6FREEBUFFER;
+    unsigned int RX7FREEBUFFER;
+    unsigned int MACCONTROL;
+    unsigned int MACSTATUS;
+    unsigned int EMCONTROL;
+    unsigned int FIFOCONTROL;
+    unsigned int MACCONFIG;
+    unsigned int SOFTRESET;
+    unsigned char RSVD5[88];
+    unsigned int MACSRCADDRLO;
+    unsigned int MACSRCADDRHI;
+    unsigned int MACHASH1;
+    unsigned int MACHASH2;
+    unsigned int BOFFTEST;
+    unsigned int TPACETEST;
+    unsigned int RXPAUSE;
+    unsigned int TXPAUSE;
+    unsigned char RSVD6[16];
+    unsigned int RXGOODFRAMES;
+    unsigned int RXBCASTFRAMES;
+    unsigned int RXMCASTFRAMES;
+    unsigned int RXPAUSEFRAMES;
+    unsigned int RXCRCERRORS;
+    unsigned int RXALIGNCODEERRORS;
+    unsigned int RXOVERSIZED;
+    unsigned int RXJABBER;
+    unsigned int RXUNDERSIZED;
+    unsigned int RXFRAGMENTS;
+    unsigned int RXFILTERED;
+    unsigned int RXQOSFILTERED;
+    unsigned int RXOCTETS;
+    unsigned int TXGOODFRAMES;
+    unsigned int TXBCASTFRAMES;
+    unsigned int TXMCASTFRAMES;
+    unsigned int TXPAUSEFRAMES;
+    unsigned int TXDEFERRED;
+    unsigned int TXCOLLISION;
+    unsigned int TXSINGLECOLL;
+    unsigned int TXMULTICOLL;
+    unsigned int TXEXCESSIVECOLL;
+    unsigned int TXLATECOLL;
+    unsigned int TXUNDERRUN;
+    unsigned int TXCARRIERSENSE;
+    unsigned int TXOCTETS;
+    unsigned int FRAME64;
+    unsigned int FRAME65T127;
+    unsigned int FRAME128T255;
+    unsigned int FRAME256T511;
+    unsigned int FRAME512T1023;
+    unsigned int FRAME1024TUP;
+    unsigned int NETOCTETS;
+    unsigned int RXSOFOVERRUNS;
+    unsigned int RXMOFOVERRUNS;
+    unsigned int RXDMAOVERRUNS;
+    unsigned char RSVD7[624];
+    unsigned int MACADDRLO;
+    unsigned int MACADDRHI;
+    unsigned int MACINDEX;
+    unsigned char RSVD8[244];
+    unsigned int TX0HDP;
+    unsigned int TX1HDP;
+    unsigned int TX2HDP;
+    unsigned int TX3HDP;
+    unsigned int TX4HDP;
+    unsigned int TX5HDP;
+    unsigned int TX6HDP;
+    unsigned int TX7HDP;
+    unsigned int RX0HDP;
+    unsigned int RX1HDP;
+    unsigned int RX2HDP;
+    unsigned int RX3HDP;
+    unsigned int RX4HDP;
+    unsigned int RX5HDP;
+    unsigned int RX6HDP;
+    unsigned int RX7HDP;
+    unsigned int TX0CP;
+    unsigned int TX1CP;
+    unsigned int TX2CP;
+    unsigned int TX3CP;
+    unsigned int TX4CP;
+    unsigned int TX5CP;
+    unsigned int TX6CP;
+    unsigned int TX7CP;
+    unsigned int RX0CP;
+    unsigned int RX1CP;
+    unsigned int RX2CP;
+    unsigned int RX3CP;
+    unsigned int RX4CP;
+    unsigned int RX5CP;
+    unsigned int RX6CP;
+    unsigned int RX7CP;
+} emac_regs;
+
+/* EMAC Wrapper Register Overlay */
+typedef volatile struct  {
+    volatile unsigned char RSVD0[4100];
+    volatile unsigned int EWCTL;
+    volatile unsigned int EWINTTCNT;
+} ewrap_regs;
+
+
+/* EMAC MDIO Register Overlay */
+typedef volatile struct  {
+    volatile unsigned int VERSION;
+    volatile unsigned int CONTROL;
+    volatile unsigned int ALIVE;
+    volatile unsigned int LINK;
+    volatile unsigned int LINKINTRAW;
+    volatile unsigned int LINKINTMASKED;
+    volatile unsigned char RSVD0[8];
+    volatile unsigned int USERINTRAW;
+    volatile unsigned int USERINTMASKED;
+    volatile unsigned int USERINTMASKSET;
+    volatile unsigned int USERINTMASKCLEAR;
+    volatile unsigned char RSVD1[80];
+    volatile unsigned int USERACCESS0;
+    volatile unsigned int USERPHYSEL0;
+    volatile unsigned int USERACCESS1;
+    volatile unsigned int USERPHYSEL1;
+} mdio_regs;
+
+
+#endif  /* _DM644X_EMAC_H_ */
diff -Naur u-boot-1.1.6/board/davinci/platform.S u-boot-1.1.6_davinci/board/davinci/platform.S
--- u-boot-1.1.6/board/davinci/platform.S	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.6_davinci/board/davinci/platform.S	2006-11-27 15:47:36.000000000 +0100
@@ -0,0 +1,760 @@
+/*
+ * Board specific setup info
+ *
+ * (C) Copyright 2003
+ * Texas Instruments, <www.ti.com>
+ * Kshitij Gupta <Kshitij@ti.com>
+ *
+ * Modified for DV-EVM board by Rishi Bhattacharya, Apr 2005
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * Modified for DV-EVM board by Swaminathan S, Nov 2005
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * MAINTENANCE HISTORY:
+ * 6/8/2006 (LT) Changed PLL clock settings for rev 1.2 Si
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <version.h>
+
+#if defined(CONFIG_OMAP1610)
+#include <./configs/omap1510.h> 
+#endif
+
+_TEXT_BASE:
+	.word	TEXT_BASE	/* sdram load addr from config.mk */
+.globl reset_cpu
+reset_cpu:
+	b reset_processor
+
+.globl lowlevel_init
+lowlevel_init:
+	/*mov	pc,	lr*/
+	
+	/*------------------------------------------------------*
+	 * mask all IRQs by setting all bits in the EINT default*
+	 *------------------------------------------------------*/
+	mov	r1, #0x00000000
+	ldr	r0, =EINT_ENABLE0
+	str	r1, [r0]
+	ldr	r0, =EINT_ENABLE1
+	str	r1, [r0]
+
+	/*------------------------------------------------------*
+	 * Put the GEM in reset		    		  *
+ 	 *------------------------------------------------------*/
+
+      /* Put the GEM in reset */
+  	LDR R8, PSC_GEM_FLAG_CLEAR
+	LDR R6, MDCTL_GEM
+	LDR R7, [R6]
+	AND R7, R7, R8
+	STR R7, [R6]
+
+	/* Enable the Power Domain Transition Command */
+	LDR R6, PTCMD_0
+	LDR R7, [R6]
+	ORR R7, R7, #0x2
+	STR R7, [R6]
+
+	/* Check for Transition Complete(PTSTAT) */
+checkStatClkStopGem:
+	LDR R6, PTSTAT_0
+	LDR R7, [R6]
+    	AND R7, R7, #0x2
+    	CMP R7, #0x0
+    	BNE checkStatClkStopGem
+
+	/* Check for GEM Reset Completion */
+checkGemStatClkStop:
+	LDR R6, MDSTAT_GEM
+	LDR R7, [R6]
+    	AND R7, R7, #0x100
+    	CMP R7, #0x0
+    	BNE checkGemStatClkStop
+
+	/* Do this for enabling a WDT initiated reset this is a workaround
+	   for a chip bug.  Not required under normal situations */
+	LDR R6, P1394
+	MOV R10, #0x0	
+	STR R10, [R6]
+
+	/*------------------------------------------------------*
+	 * Enable L1 & L2 Memories in Fast mode                 *
+	 *------------------------------------------------------*/
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x1
+	STR R10, [R6]
+
+	LDR R6, MMARG_BRF0
+	LDR R10, MMARG_BRF0_VAL
+	STR R10, [R6]
+
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x0
+	STR R10, [R6]
+	
+	/*------------------------------------------------------*
+	 * DDR2 PLL Intialization			    	*
+ 	 *------------------------------------------------------*/
+	
+      /* Select the Clock Mode Depending on the Value written in the Boot Table by the run script */
+	MOV R10, #0x0
+	LDR R6, PLL2_CTL   
+	LDR R7, PLL_CLKSRC_MASK
+	LDR R8, [R6]
+	AND R8, R8, R7
+	MOV R9, R10, LSL #0x8
+	ORR R8, R8, R9
+	STR R8, [R6]
+	
+	/* Select the PLLEN source */
+	LDR R7, PLL_ENSRC_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Bypass the PLL */
+	LDR R7, PLL_BYPASS_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Wait for few cycles to allow PLLEN Mux switches properly to bypass Clock */
+	MOV R10, #0x20 
+WaitPPL2Loop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE WaitPPL2Loop	
+
+     /* Reset the PLL */
+    	LDR R7, PLL_RESET_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+     /* Power up the PLL */
+    	LDR R7, PLL_PWRUP_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+     /* Enable the PLL from Disable Mode */
+    	LDR R7, PLL_DISABLE_ENABLE_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+	/* Program the PLL Multiplier */
+	LDR R6, PLL2_PLLM
+	/*MOV R2, #0x13 Orig value */
+	/*MOV R2, #0xB 165MHz */
+	/*MOV R2, #0xD 189 MHz */
+	MOV R2, #0x17 /* 162 MHz */
+	STR R2, [R6]   /* R2 */
+
+	/* Program the PLL2 Divisior Value */
+	LDR R6, PLL2_DIV2
+	MOV R3, #0x1 /*Orig */
+	/*MOV R3, #0x0*/
+	STR R3, [R6]    /* R3 */
+
+	/* Program the PLL2 Divisior Value */
+	LDR R6, PLL2_DIV1
+	/*MOV R4, #0x9 Orig */
+	/*MOV R4, #0x5 54MHz */
+	MOV R4, #0xB /* 54 MHz */
+	STR R4, [R6]    /* R4 */
+
+      /* PLL2 DIV1 MMR */
+	LDR R8, PLL2_DIV_MASK
+	LDR R6, PLL2_DIV2
+	LDR R9, [R6]
+	AND R8, R8, R9
+	MOV R9, #0X1
+	MOV R9, R9, LSL #15
+	ORR R8, R8, R9
+	STR R8, [R6]
+
+	/* Program the GOSET bit to take new divier values */
+	LDR R6, PLL2_PLLCMD
+	LDR R7, [R6]
+	ORR R7, R7, #0x1
+	STR R7, [R6]
+
+      /* Wait for Done */
+    	LDR R6, PLL2_PLLSTAT
+doneLoop_0:    
+    	LDR R7, [R6]
+    	AND R7, R7, #0x1
+    	CMP R7, #0x0
+    	BNE doneLoop_0
+
+      /* PLL2 DIV2 MMR */
+	LDR R8, PLL2_DIV_MASK
+	LDR R6, PLL2_DIV1
+	LDR R9, [R6]
+	AND R8, R8, R9
+	MOV R9, #0X1
+	MOV R9, R9, LSL #15
+	ORR R8, R8, R9
+	STR R8, [R6]
+
+	/* Program the GOSET bit to take new divier values */
+	LDR R6, PLL2_PLLCMD
+	LDR R7, [R6]
+	ORR R7, R7, #0x1
+	STR R7, [R6]
+
+     /* Wait for Done */
+    	LDR R6, PLL2_PLLSTAT
+doneLoop:    
+    	LDR R7, [R6]
+    	AND R7, R7, #0x1
+    	CMP R7, #0x0
+    	BNE doneLoop
+    				
+	/* Wait for PLL to Reset Properly */
+	MOV R10, #0x218  
+ResetPPL2Loop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE ResetPPL2Loop
+    
+    	/* Bring PLL out of Reset */
+    	LDR R6, PLL2_CTL    	
+    	LDR R8, [R6]
+    	ORR R8, R8, #0x08
+    	STR R8, [R6]
+     	
+     /* Wait for PLL to Lock */
+	LDR R10, PLL_LOCK_COUNT    
+PLL2Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE PLL2Lock
+    
+     /* Enable the PLL */
+    	LDR R6, PLL2_CTL    	
+    	LDR R8, [R6]
+    	ORR R8, R8, #0x01
+    	STR R8, [R6]
+
+	/*------------------------------------------------------*
+	 * Issue Soft Reset to DDR Module		    		  *
+ 	 *------------------------------------------------------*/
+
+      /* Shut down the DDR2 LPSC Module */
+  	LDR R8, PSC_FLAG_CLEAR
+	LDR R6, MDCTL_DDR2_0
+	LDR R7, [R6]
+	AND R7, R7, R8
+	ORR R7, R7, #0x3
+	STR R7, [R6]  
+
+	/* Enable the Power Domain Transition Command */
+	LDR R6, PTCMD_0
+	LDR R7, [R6]
+	ORR R7, R7, #0x1
+	STR R7, [R6]    
+	
+	/* Check for Transition Complete(PTSTAT) */
+checkStatClkStop:	
+	LDR R6, PTSTAT_0
+	LDR R7, [R6]
+    	AND R7, R7, #0x1	
+    	CMP R7, #0x0
+    	BNE checkStatClkStop  
+    
+	/* Check for DDR2 Controller Enable Completion */
+checkDDRStatClkStop:	
+	LDR R6, MDSTAT_DDR2_0
+	LDR R7, [R6]
+    	AND R7, R7, #0x1F	
+    	CMP R7, #0x3
+    	BNE checkDDRStatClkStop  
+
+	/*------------------------------------------------------*
+	 * Program DDR2 MMRs for 162MHz Setting	    		  *
+ 	 *------------------------------------------------------*/
+	
+	/* Program PHY Control Register */
+	LDR R6, DDRCTL
+	LDR R7, DDRCTL_VAL
+	STR R7, [R6]
+
+	/* Program SDRAM Bank Config Register */
+	LDR R6, SDCFG
+	LDR R7, SDCFG_VAL
+	STR R7, [R6]
+
+	/* Program SDRAM TIM-0 Config Register */
+	LDR R6, SDTIM0
+	LDR R7, SDTIM0_VAL_162MHz
+	STR R7, [R6]		
+
+	/* Program SDRAM TIM-1 Config Register */
+	LDR R6, SDTIM1
+	LDR R7, SDTIM1_VAL_162MHz
+	STR R7, [R6]		
+
+	/* Program the SDRAM Bang Config Control Register */
+	LDR R10, MASK_VAL
+	LDR R8, SDCFG
+	LDR R9, SDCFG_VAL
+	AND R9, R9, R10
+	STR R9, [R8]
+
+	/* Program SDRAM TIM-1 Config Register */
+	LDR R6, SDREF
+	LDR R7, SDREF_VAL
+	STR R7, [R6]		
+
+        /*------------------------------------------------------*
+         * Issue Soft Reset to DDR Module                                 *
+         *------------------------------------------------------*/
+                                                                                
+        /* Issue a Dummy DDR2 read/write */
+        LDR R8, DDR2_VAL
+        LDR R7, DUMMY_VAL
+        STR R7, [R8]
+        LDR R7, [R8]
+                                                                                
+      /* Shut down the DDR2 LPSC Module */
+        LDR R8, PSC_FLAG_CLEAR
+        LDR R6, MDCTL_DDR2_0
+        LDR R7, [R6]
+        AND R7, R7, R8
+        ORR R7, R7, #0x1
+        STR R7, [R6]
+                                                                                
+        /* Enable the Power Domain Transition Command */
+        LDR R6, PTCMD_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x1
+        STR R7, [R6]
+                                                                                
+        /* Check for Transition Complete(PTSTAT) */
+checkStatClkStop2:
+        LDR R6, PTSTAT_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1
+        CMP R7, #0x0
+        BNE checkStatClkStop2
+                                                                                
+        /* Check for DDR2 Controller Enable Completion */
+checkDDRStatClkStop2:
+        LDR R6, MDSTAT_DDR2_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1F
+        CMP R7, #0x1
+        BNE checkDDRStatClkStop2
+
+        /*------------------------------------------------------*
+         * Turn DDR2 Controller Clocks On                                 *
+         *------------------------------------------------------*/
+                                                                                
+     /* Enable the DDR2 LPSC Module */
+        LDR R6, MDCTL_DDR2_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x3
+        STR R7, [R6]
+                                                                                
+        /* Enable the Power Domain Transition Command */
+        LDR R6, PTCMD_0
+        LDR R7, [R6]
+        ORR R7, R7, #0x1
+        STR R7, [R6]
+                                                                                
+        /* Check for Transition Complete(PTSTAT) */
+checkStatClkEn2:
+        LDR R6, PTSTAT_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1
+        CMP R7, #0x0
+        BNE checkStatClkEn2
+                                                                                
+        /* Check for DDR2 Controller Enable Completion */
+checkDDRStatClkEn2:
+        LDR R6, MDSTAT_DDR2_0
+        LDR R7, [R6]
+        AND R7, R7, #0x1F
+        CMP R7, #0x3
+        BNE checkDDRStatClkEn2
+                                                                                
+        /*  DDR Writes and Reads */
+        LDR R6, CFGTEST
+        MOV R3, #0x1
+        STR R3, [R6]    /* R3 */
+
+	/*------------------------------------------------------*
+	 * System PLL Intialization			    		  *
+ 	 *------------------------------------------------------*/
+
+      /* Select the Clock Mode Depending on the Value written in the Boot Table by the run script */
+	MOV R2, #0x0
+	LDR R6, PLL1_CTL   
+	LDR R7, PLL_CLKSRC_MASK
+	LDR R8, [R6]
+	AND R8, R8, R7
+	MOV R9, R2, LSL #0x8
+	ORR R8, R8, R9
+	STR R8, [R6]
+	
+	/* Select the PLLEN source */
+	LDR R7, PLL_ENSRC_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Bypass the PLL */
+	LDR R7, PLL_BYPASS_MASK
+	AND R8, R8, R7
+	STR R8, [R6]
+	
+	/* Wait for few cycles to allow PLLEN Mux switches properly to bypass Clock */
+	MOV R10, #0x20 
+
+WaitLoop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE WaitLoop	
+
+     /* Reset the PLL */
+    	LDR R7, PLL_RESET_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+      /* Disable the PLL */
+    	ORR R8, R8, #0x10    
+    	STR R8, [R6]
+
+      /* Power up the PLL */
+    	LDR R7, PLL_PWRUP_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+      /* Enable the PLL from Disable Mode */
+    	LDR R7, PLL_DISABLE_ENABLE_MASK	
+	AND R8, R8, R7
+	STR R8, [R6]
+
+	/* Program the PLL Multiplier */
+	LDR R6, PLL1_PLLM
+	/*MOV R3, #0x10  As per Amit, PLL should be in normal mode i.e X by 16 */
+	/*MOV R3, #0x11  As per Ebby 486 MHz */
+	/*MOV R3, #0x14  For 567 MHz */
+	MOV R3, #0x15 /* For 594 MHz */
+	STR R3, [R6]      
+
+	/* Wait for PLL to Reset Properly */
+	MOV R10, #0xFF 
+
+ResetLoop:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE ResetLoop
+    
+      /* Bring PLL out of Reset */
+    	LDR R6, PLL1_CTL    	
+    	ORR R8, R8, #0x08
+    	STR R8, [R6]
+     	
+      /* Wait for PLL to Lock */
+	LDR R10, PLL_LOCK_COUNT    
+
+PLL1Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE PLL1Lock
+    
+      /* Enable the PLL */
+    	ORR R8, R8, #0x01
+    	STR R8, [R6]
+
+	nop
+	nop	
+	nop
+	nop
+
+	/*------------------------------------------------------*
+	 * AEMIF configuration for NOR Flash (double check)     *
+	 *------------------------------------------------------*/
+	LDR R0, _PINMUX0
+	LDR R1, _DEV_SETTING
+	STR R1, [R0]
+
+ 	LDR R0, WAITCFG   
+	LDR R1, WAITCFG_VAL 
+	LDR R2, [R0]
+	ORR R2, R2, R1
+	STR R2, [R0]    
+
+	LDR R0, ACFG3
+	LDR R1, ACFG3_VAL
+	LDR R2, [R0]
+	AND R1, R2, R1
+	STR R1, [R0]
+
+	LDR R0, ACFG4
+	LDR R1, ACFG4_VAL
+	LDR R2, [R0]
+	AND R1, R2, R1
+	STR R1, [R0]
+
+	LDR R0, ACFG5
+	LDR R1, ACFG5_VAL
+	LDR R2, [R0]
+	AND R1, R2, R1
+	STR R1, [R0]     
+
+	/*--------------------------------------*
+	 * VTP manual Calibration               *
+	 *--------------------------------------*/
+	LDR R0, VTPIOCR
+	LDR R1, VTP_MMR0
+	STR R1, [R0]
+
+	LDR R0, VTPIOCR
+	LDR R1, VTP_MMR1
+	STR R1, [R0]
+	
+     /* Wait for 33 VTP CLK cycles.  VRP operates at 27 MHz */
+	LDR R10, VTP_LOCK_COUNT    
+VTPLock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE VTPLock
+
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x1
+	STR R10, [R6]
+
+	LDR R6, DDRVTPR
+	LDR R7, [R6]
+	AND R7, R7, #0x1F
+	AND R8, R7, #0x3E0
+	ORR R8, R7, R8
+	LDR R7, VTP_RECAL
+	ORR R8, R7, R8
+	LDR R7, VTP_EN
+	ORR R8, R7, R8
+	STR R8, [R0]
+
+
+     /* Wait for 33 VTP CLK cycles.  VRP operates at 27 MHz */
+	LDR R10, VTP_LOCK_COUNT    
+VTP1Lock:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE VTP1Lock
+
+	LDR R1, [R0]
+	LDR R2, VTP_MASK
+	AND R2, R1, R2
+	STR R2, [R0]
+
+	LDR R6, DFT_ENABLE
+	MOV R10, #0x0
+	STR R10, [R6]
+
+
+	/* Start MPU Timer 1 */
+/*	MOV R10, #0x1AFFFFFF
+
+WaitRam:
+    	SUB R10, R10, #0x1
+    	CMP R10, #0x0
+    	BNE WaitRam
+*/
+	/* back to arch calling code */
+	mov	pc,	lr
+
+	/* the literal pools origin */
+	.ltorg
+
+REG_TC_EMIFS_CONFIG:		/* 32 bits */
+	.word 0xfffecc0c
+REG_TC_EMIFS_CS0_CONFIG:	/* 32 bits */
+	.word 0xfffecc10
+REG_TC_EMIFS_CS1_CONFIG:	/* 32 bits */
+	.word 0xfffecc14
+REG_TC_EMIFS_CS2_CONFIG:	/* 32 bits */
+	.word 0xfffecc18
+REG_TC_EMIFS_CS3_CONFIG:	/* 32 bits */
+	.word 0xfffecc1c
+
+_PINMUX0:		.word   0x01C40000		/* Device Configuration Registers */
+_PINMUX1:		.word   0x01C40004		/* Device Configuration Registers */
+
+_DEV_SETTING:		.word   0x00000C1F
+
+AEMIF_BASE_ADDR:	.word   0x01E00000
+WAITCFG:         	.word   0x01E00004
+ACFG2:           	.word   0x01E00010
+ACFG3:           	.word   0x01E00014
+ACFG4:           	.word   0x01E00018
+ACFG5:           	.word   0x01E0001C
+
+WAITCFG_VAL:     	.word   0x0
+ACFG2_VAL:       	.word   0x3FFFFFFD
+ACFG3_VAL:       	.word   0x3FFFFFFD
+ACFG4_VAL:       	.word   0x3FFFFFFD
+ACFG5_VAL:       	.word   0x3FFFFFFD
+
+MDCTL_DDR2:		.word   0x01C41A34
+PTCMD:		        .word   0x01C41120
+PTSTAT:		        .word   0x01C41128
+MDSTAT_DDR2:	        .word   0x01C41834
+
+MDCTL_TPCC:		.word   0x01C41A08
+MDSTAT_TPCC:	        .word   0x01C41808
+
+MDCTL_TPTC0:	        .word	0x01C41A0C
+MDSTAT_TPTC0:	        .word   0x01C4180C
+
+MDCTL_TPTC1:	        .word	0x01C41A10
+MDSTAT_TPTC1:	        .word   0x01C41810
+
+DDR2DEBUG:		.word   0x8FFFF000
+
+/* EINT0 register */
+EINT_ENABLE0:
+	.word 0x01c48018
+
+/* EINT1 register */
+EINT_ENABLE1:
+	.word 0x01c4801C
+
+CLEAR_FLAG:			.word   0xFFFFFFFF
+EDMA_PARAM0_D_S_BIDX_VAL: 	.word   0x00010001
+PSC_FLAG_CLEAR:                 .word   0xFFFFFFE0
+PSC_GEM_FLAG_CLEAR:		.word   0xFFFFFEFF
+MDCTL_TPCC_SYNC:		.word   0x01C41A08
+MDSTAT_TPCC_SYNC:		.word   0x01C41808
+
+MDCTL_TPTC0_SYNC:		.word   0x01C41A0C
+MDSTAT_TPTC0_SYNC:		.word   0x01C4180C
+
+MDCTL_TPTC1_SYNC:		.word   0x01C41A10
+MDSTAT_TPTC1_SYNC:		.word   0x01C41810
+
+PTCMD_SYNC:			.word   0x01C41120
+PTSTAT_SYNC:			.word   0x01C41128
+DATA_MAX:			.word   0x0000FFFF
+SPIN_ADDR:			.word   0x00003FFC   /* ARM PC value(B $) for the DSP Test cases */
+SPIN_OPCODE:			.word   0xEAFFFFFE
+
+/* Interrupt Clear Register */
+FIQ0_CLEAR:			.word   0x01C48000
+FIQ1_CLEAR:			.word   0x01C48004
+IRQ0_CLEAR:			.word   0x01C48008
+IRQ1_CLEAR:			.word   0x01C4800C
+
+/* DDR2 MMR & CONFIGURATION VALUES for 75 MHZ */
+DDRCTL:				.word	0x200000E4
+SDREF:				.word	0x2000000C
+SDCFG:				.word	0x20000008
+SDTIM0:				.word	0x20000010
+SDTIM1:				.word	0x20000014
+SDSTAT:				.word   0x20000004
+VTPIOCR:			.word   0x200000F0  /* VTP IO Control register */
+DDRVTPR:			.word   0x01C42030  /* DDR VPTR MMR */
+DFT_ENABLE:			.word   0x01C4004C
+VTP_MMR0:			.word   0x201F
+VTP_MMR1:			.word   0xA01F
+PCH_MASK:			.word   0x3E0
+VTP_LOCK_COUNT:			.word   0x5b0
+VTP_MASK:			.word   0xFFFFDFFF
+VTP_RECAL:			.word   0x40000
+VTP_EN:				.word   0x02000
+
+
+CFGTEST:			.word	0x80010000
+
+/* original values					
+DDRCTL_VAL:			.word	0x50006405
+SDCFG_VAL:			.word	0x00008832
+MASK_VAL:                    	.word   0x00000FFF
+SDTIM0_VAL_135MHz:		.word	0x30923A91
+SDTIM1_VAL_135MHz:		.word	0x0019c722
+SDREF_VAL:			.word   0x000005c3
+*/
+
+/* 162MHz as per GEL file for DVEVM with Micron DDR2 SDRAM */
+DDRCTL_VAL:                     .word	0x50006405
+SDCFG_VAL:			.word	0x00178632           /* CL=3 for MT47H64M16BT-5E */
+MASK_VAL:                    	.word   0x00000FFF
+SDTIM0_VAL_162MHz:		.word	0x28923211
+SDTIM1_VAL_162MHz:		.word	0x0016c722
+SDREF_VAL:                      .word   0x000004F0
+
+/* GEM Power Up & LPSC Control Register */
+CHP_SHRTSW:			.word   0x01C40038
+
+PD1_CTL:			.word	0x01C41304
+EPCPR:				.word	0x01C41070
+EPCCR:				.word	0x01C41078
+MDCTL_GEM:			.word	0x01C41A9C
+MDSTAT_GEM:			.word   0x01C4189C
+MDCTL_IMCOP:			.word	0x01C41AA0
+MDSTAT_IMCOP:			.word   0x01C418A0
+
+PTCMD_0:			.word   0x01C41120
+PTSTAT_0:			.word   0x01C41128
+P1394:				.word   0x01C41a20
+
+PLL_CLKSRC_MASK: 		.word   0xFFFFFEFF  /* Mask the Clock Mode bit and it is programmble through the run script */
+PLL_ENSRC_MASK:  		.word   0xFFFFFFDF  /* Select the PLLEN source */
+PLL_BYPASS_MASK: 		.word   0xFFFFFFFE  /* Put the PLL in BYPASS, eventhough the device */
+PLL_RESET_MASK:  		.word   0xFFFFFFF7  /* Put the PLL in Reset Mode */
+PLL_PWRUP_MASK:  		.word   0xFFFFFFFD  /* PLL Power up Mask Bit  */
+PLL_DISABLE_ENABLE_MASK:	.word   0xFFFFFFEF  /* Enable the PLL from Disable */
+PLL_LOCK_COUNT:          	.word   0x2000
+
+/* PLL1-SYSTEM PLL MMRs */
+PLL1_CTL:			.word   0x01C40900 
+PLL1_PLLM:			.word   0x01C40910
+
+/* PLL2-SYSTEM PLL MMRs */
+PLL2_CTL:			.word   0x01C40D00 
+PLL2_PLLM:			.word   0x01C40D10
+PLL2_DIV2:			.word   0x01C40D1C
+PLL2_DIV1:			.word   0x01C40D18
+PLL2_PLLCMD:			.word   0x01C40D38
+PLL2_PLLSTAT:			.word   0x01C40D3C	
+PLL2_BPDIV:			.word   0x01C40D2C
+PLL2_DIV_MASK:			.word   0xFFFF7FFF
+
+
+MDCTL_DDR2_0:			.word   0x01C41A34
+MDSTAT_DDR2_0:			.word   0x01C41834
+DLLPWRUPMASK:			.word   0xFFFFFFEF
+DDR2_ADDR:			.word   0x80000000
+
+DFT_BASEADDR:			.word   0x01C42000
+MMARG_BRF0:			.word   0x01C42010     /* BRF margin mode 0     (Read / write)*/
+MMARG_G10:			.word   0x01C42018     /*GL margin mode 0      (Read / write)*/
+MMARG_BRF0_VAL:			.word   0x00444400
+DDR2_VAL:			.word   0x80000000
+DUMMY_VAL:			.word   0xA55AA55A
+
+/* command values */
+.equ CMD_SDRAM_NOP,		0x00000000
+.equ CMD_SDRAM_PRECHARGE,	0x00000001
+.equ CMD_SDRAM_AUTOREFRESH,	0x00000002
+.equ CMD_SDRAM_CKE_SET_HIGH,	0x00000007
diff -Naur u-boot-1.1.6/board/davinci/soc.h u-boot-1.1.6_davinci/board/davinci/soc.h
--- u-boot-1.1.6/board/davinci/soc.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.6_davinci/board/davinci/soc.h	2006-11-27 13:45:30.000000000 +0100
@@ -0,0 +1,332 @@
+/*
+ *
+ *  Copyright (C) 2004 Texas Instruments.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ * Modifications:
+ * ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+
+#ifndef _SOC_H
+#define _SOC_H
+
+#define CSL_IDEF_INLINE static inline
+/*****************************************************************************\
+* Peripheral Instance counts
+\*****************************************************************************/
+
+#define CSL_UART_CNT                 3
+#define CSL_I2C_CNT                  1
+#define CSL_TMR_CNT                  4
+#define CSL_WDT_CNT                  1
+#define CSL_PWM_CNT                  3
+#define CSL_PLLC_CNT                 2
+#define CSL_PWR_SLEEP_CTRL_CNT       1
+#define CSL_SYS_DFT_CNT              1
+#define CSL_INTC_CNT                 1
+#define CSL_IEEE1394_CNT             1
+#define CSL_USBOTG_CNT               1
+#define CSL_ATA_CNT                  1
+#define CSL_SPI_CNT                  1
+#define CSL_GPIO_CNT                 1
+#define CSL_UHPI_CNT                 1
+#define CSL_VPSS_REGS_CNT            1
+#define CSL_EMAC_CTRL_CNT            1
+#define CSL_EMAC_WRAP_CNT            1
+#define CSL_EMAC_RAM_CNT             1
+#define CSL_MDIO_CNT                 1
+#define CSL_EMIF_CNT                 1
+#define CSL_NAND_CNT                 1
+#define CSL_MCBSP_CNT                1
+#define CSL_MMCSD_CNT                1
+#define CSL_MS_CNT                   1
+#define CSL_DDR_CNT                  1
+#define CSL_VLYNQ_CNT                1
+#define CSL_PMX_CNT                  1
+
+/*****************************************************************************\
+* Peripheral Instance enumeration
+\*****************************************************************************/
+
+/** @brief Peripheral Instance for UART  */
+#define CSL_UART_1                          (0) /** Instance 1 of UART   */
+
+/** @brief Peripheral Instance for UART  */
+#define CSL_UART_2                          (1) /** Instance 2 of UART   */
+
+/** @brief Peripheral Instance for UART  */
+#define CSL_UART_3                          (2) /** Instance 3 of UART   */
+
+/** @brief Peripheral Instance for I2C   */
+#define CSL_I2C                             (0) /** Instance 1 of I2C    */
+
+/** @brief Peripheral Instance for Tmr0  */
+#define CSL_TMR_1                           (0) /** Instance 1 of Tmr    */
+
+/** @brief Peripheral Instance for Tmr1  */
+#define CSL_TMR_2                           (1) /** Instance 2 of Tmr    */
+
+/** @brief Peripheral Instance for Tmr2  */
+#define CSL_TMR_3                           (2) /** Instance 3 of Tmr    */
+
+/** @brief Peripheral Instance for Tmr3  */
+#define CSL_TMR_4                           (3) /** Instance 4 of Tmr    */
+
+/** @brief Peripheral Instance for WDT   */
+#define CSL_WDT                             (0) /** Instance of WDT      */
+
+/** @brief Peripheral Instance for PWM   */
+#define CSL_PWM_1                           (0) /** Instance 1 of PWM    */
+
+/** @brief Peripheral Instance for PWM   */
+#define CSL_PWM_2                           (1) /** Instance 2 of PWM    */
+
+/** @brief Peripheral Instance for PWM   */
+#define CSL_PWM_3                           (2) /** Instance 3 of PWM    */
+
+/** @brief Peripheral Instance for PLLC  */
+#define CSL_PLLC_1                          (0) /** Instance 1 of PLLC   */
+
+/** @brief Peripheral Instance for PLLC  */
+#define CSL_PLLC_2                          (1) /** Instance 2 of PLLC   */
+
+/** @brief Peripheral Instance for CSL_PWR_SLEEP_CTRL  */
+#define CSL_PWR_SLEEP_CTRL                  (0) /** Instance 1 of PWR_SLEEP_CTRL    */
+
+/** @brief Peripheral Instance for SYS_DFT  */
+#define CSL_SYS_DFT                         (0) /** Instance 1 of SYS_DFT*/
+
+/** @brief Peripheral Instance for INTC   */
+#define CSL_INTC                            (0) /** Instance 1 of INTC   */
+
+/** @brief Peripheral Instance for IEEE 1394  */
+#define CSL_IEEE1394                       (0) /** Instance 1 of IEEE 1394     */
+
+/** @brief Peripheral Instance for USBOTG  */
+#define CSL_USBOTG                          (0) /** Instance 1 of USBOTG */
+
+/** @brief Peripheral Instance for ATA   */
+#define CSL_ATA_PRIMARY                     (0) /** Instance 1 of ATA    */
+
+/** @brief Peripheral Instance for ATA   */
+#define CSL_ATA_SECONDARY                   (1) /** Instance 2 of ATA    */
+
+/** @brief Peripheral Instance for SPI   */
+#define CSL_SPI                             (0) /** Instance 1 of SPI    */
+
+/** @brief Peripheral Instance for GPIO  */
+#define CSL_GPIO                            (0) /** Instance 1 of GPIO   */
+
+/** @brief Peripheral Instance for UHPI  */
+#define CSL_UHPI                            (0) /** Instance 1 of UHPI   */
+
+/** @brief Peripheral Instance for VPSS_REGS  */
+#define CSL_VPSS_REGS                       (0) /** Instance 1 of VPSS_REGS     */
+
+/** @brief Peripheral Instance for EMAC_CTRL  */
+#define CSL_EMAC_CTRL                       (0) /** Instance 1 of EMAC_CTRL     */
+
+/** @brief Peripheral Instance for EMAC_WRAP  */
+#define CSL_EMAC_WRAP                       (0) /** Instance 1 of EMAC_WRAP     */
+
+/** @brief Peripheral Instance for EMAC_RAM  */
+#define CSL_EMAC_RAM                        (0) /** Instance 1 of EMAC_RAM      */
+
+/** @brief Peripheral Instance for MDIO  */
+#define CSL_MDIO                            (0) /** Instance 1 of MDIO   */
+
+/** @brief Peripheral Instance for EMIF  */
+#define CSL_EMIF                            (0) /** Instance 1 of EMIF   */
+
+/** @brief Peripheral Instance for NAND  */
+#define CSL_NAND                            (0) /** Instance 1 of NAND   */
+
+/** @brief Peripheral Instance for MCBSP */
+#define CSL_MCBSP                           (0) /** Instance 1 of MCBSP  */
+
+/** @brief Peripheral Instance for MMCSD */
+#define CSL_MMCSD                           (0) /** Instance 1 of MMCSD  */
+
+/** @brief Peripheral Instance for MS    */
+#define CSL_MS                              (0) /** Instance 1 of MS     */
+
+/** @brief Peripheral Instance for DDR    */
+#define CSL_DDR                             (0) /** Instance 1 of DDR    */
+
+/** @brief Peripheral Instance for VLYNQ */
+#define CSL_VLYNQ                           (0) /** Instance 1 of VLYNQ  */
+
+/** @brief Peripheral Instance for PMX */
+#define CSL_PMX                             (0) /** Instance 1 of PMX    */
+
+/*****************************************************************************\
+* Peripheral Base Address
+\*****************************************************************************/
+
+#define CSL_UART_1_REGS                  (0x01C20000)
+#define CSL_UART_2_REGS                  (0x01C20400)
+#define CSL_UART_3_REGS                  (0x01C20800)
+#define CSL_I2C_1_REGS                   (0x01C21000)
+#define CSL_TMR_1_REGS                   (0x01C21400)
+#define CSL_TMR_2_REGS                   (0x01C21400)
+#define CSL_TMR_3_REGS                   (0x01C21800)
+#define CSL_TMR_4_REGS                   (0x01C21800)
+#define CSL_WDT_1_REGS                   (0x01C21C00)
+#define CSL_PWM_1_REGS                   (0x01C22000)
+#define CSL_PWM_2_REGS                   (0x01C22400)
+#define CSL_PWM_3_REGS                   (0x01C22800)
+#define CSL_PLLC_1_REGS                  (0x01C40800)
+#define CSL_PLLC_2_REGS                  (0x01C40C00)
+#define CSL_PWR_SLEEP_CTRL_1_REGS        (0x01C41000)
+#define CSL_SYS_DFT_1_REGS               (0x01C42000)
+#define CSL_INTC1_REGS                   (0x01C48000)
+#define CSL_IEEE1394_1_REGS              (0x01C60000)
+#define CSL_USBOTG_1_REGS                (0x01C48000)
+#define CSL_ATA_1_REGS                   (0x01C66000)
+#define CSL_SPI_1_REGS                   (0x01C66800)
+#define CSL_GPIO_1_REGS                  (0x01C67000)
+#define CSL_UHPI_1_REGS                  (0x01C67800)
+#define CSL_VPSS_REGS_1_REGS             (0x01C70000)
+#define CSL_EMAC_CTRL_1_REGS             (0x01C80000)
+#define CSL_EMAC_WRAP_1_REGS             (0x01C81000)
+#define CSL_EMAC_RAM_1_REGS              (0x01C82000)
+#define CSL_MDIO_1_REGS                  (0x01C84000)
+#define CSL_EMIF_1_REGS                  (0x01E00000)
+#define CSL_NAND_1_REGS                  (0x01E00000)
+#define CSL_MCBSP_1_REGS                 (0x01E02000)
+#define CSL_MMCSD_1_REGS                 (0x01E10000)
+#define CSL_MS_1_REGS                    (0x01E20000)
+#define CSL_DDR_1_REGS                   (0x20000000)
+#define CSL_VLYNQ_1_REGS                 (0x01E01000)
+#define CSL_PMX_1_REGS                   (0x01DEAD00) // TODO: Get correct base address.
+
+/* Added for EDMA  */
+/** @brief Base address of Channel controller  memory mapped registers */
+#define CSL_EDMACC_1_REGS                 (0x01C00000u)
+#define CSL_EDMA_1                         0
+
+
+/*****************************************************************************\
+* Interrupt/Exception Counts
+\*****************************************************************************/
+
+#define _CSL_INTC_EVENTID__INTC0CNT     (8)      /* ARM exception count     */
+#define _CSL_INTC_EVENTID__INTC1CNT     (64)     /* Level-1 Interrupt count */
+
+/**
+ * @brief   Count of the number of interrupt-events
+ */
+#define CSL_INTC_EVENTID_CNT        \
+    (_CSL_INTC_EVENTID__INTC0CNT + _CSL_INTC_EVENTID__INTC1CNT)
+
+/*****************************************************************************\
+* Interrupt Event IDs
+\*****************************************************************************/
+
+#define   _CSL_INTC_EVENTID__SPURIOUS         (0)
+#define   _CSL_INTC_EVENTID__INTC1START       (0)
+
+#define   CSL_INTC_EVENTID_VD0           (_CSL_INTC_EVENTID__INTC1START + 0)  /**< VPSS - CCDC      */
+#define   CSL_INTC_EVENTID_VD1           (_CSL_INTC_EVENTID__INTC1START + 1)  /**< VPSS - CCDC      */
+#define   CSL_INTC_EVENTID_VD2           (_CSL_INTC_EVENTID__INTC1START + 2)  /**< VPSS - CCDC      */
+#define   CSL_INTC_EVENTID_HIST          (_CSL_INTC_EVENTID__INTC1START + 3)  /**< VPSS - Histogram */
+#define   CSL_INTC_EVENTID_H3A           (_CSL_INTC_EVENTID__INTC1START + 4)  /**< VPSS - AE/AWB/AF */
+#define   CSL_INTC_EVENTID_PRVU          (_CSL_INTC_EVENTID__INTC1START + 5)  /**< VPSS - Previewer */
+#define   CSL_INTC_EVENTID_RSZ           (_CSL_INTC_EVENTID__INTC1START + 6)  /**< VPSS - Resizer   */
+#define   CSL_INTC_EVENTID_VFOC          (_CSL_INTC_EVENTID__INTC1START + 7)  /**< VPSS - Focus     */
+#define   CSL_INTC_EVENTID_VENC          (_CSL_INTC_EVENTID__INTC1START + 8)  /**< VPSS - VPBE      */
+#define   CSL_INTC_EVENTID_ASQ           (_CSL_INTC_EVENTID__INTC1START + 9)  /**< IMCOP - Sqr      */
+#define   CSL_INTC_EVENTID_IMX           (_CSL_INTC_EVENTID__INTC1START + 10) /**< IMCOP - iMX      */
+#define   CSL_INTC_EVENTID_VLCD          (_CSL_INTC_EVENTID__INTC1START + 11) /**< IMCOP - VLCD     */
+#define   CSL_INTC_EVENTID_USBC          (_CSL_INTC_EVENTID__INTC1START + 12) /**< USB OTG Collector*/
+#define   CSL_INTC_EVENTID_EMAC          (_CSL_INTC_EVENTID__INTC1START + 13) /**< CPGMAC Wrapper   */
+#define   CSL_INTC_EVENTID_1394          (_CSL_INTC_EVENTID__INTC1START + 14) /**< IEEE1394         */
+#define   CSL_INTC_EVENTID_1394WK        (_CSL_INTC_EVENTID__INTC1START + 15) /**< IEEE1394         */
+#define   CSL_INTC_EVENTID_CC0           (_CSL_INTC_EVENTID__INTC1START + 16) /**< 3PCC Region 0    */
+#define   CSL_INTC_EVENTID_CCERR         (_CSL_INTC_EVENTID__INTC1START + 17) /**< 3PCC Error       */
+#define   CSL_INTC_EVENTID_TCERR0        (_CSL_INTC_EVENTID__INTC1START + 18) /**< 3PTC0 Error      */
+#define   CSL_INTC_EVENTID_TCERR1        (_CSL_INTC_EVENTID__INTC1START + 19) /**< 3PTC1 Error      */
+#define   CSL_INTC_EVENTID_PSCINT        (_CSL_INTC_EVENTID__INTC1START + 20) /**< PSC - ALLINT     */
+#define   CSL_INTC_EVENTID_RSVD21        (_CSL_INTC_EVENTID__INTC1START + 21) /**< Reserved         */
+#define   CSL_INTC_EVENTID_ATA           (_CSL_INTC_EVENTID__INTC1START + 22) /**< ATA/IDE          */
+#define   CSL_INTC_EVENTID_HPIINT        (_CSL_INTC_EVENTID__INTC1START + 23) /**< UHPI             */
+#define   CSL_INTC_EVENTID_MBX           (_CSL_INTC_EVENTID__INTC1START + 24) /**< McBSP            */
+#define   CSL_INTC_EVENTID_MBR           (_CSL_INTC_EVENTID__INTC1START + 25) /**< McBSP            */
+#define   CSL_INTC_EVENTID_MMCSD         (_CSL_INTC_EVENTID__INTC1START + 26) /**< MMC/SD           */
+#define   CSL_INTC_EVENTID_SDIO          (_CSL_INTC_EVENTID__INTC1START + 27) /**< MMC/SD           */
+#define   CSL_INTC_EVENTID_MS            (_CSL_INTC_EVENTID__INTC1START + 28) /**< Memory Stick     */
+#define   CSL_INTC_EVENTID_DDR           (_CSL_INTC_EVENTID__INTC1START + 29) /**< DDR EMIF         */
+#define   CSL_INTC_EVENTID_EMIF          (_CSL_INTC_EVENTID__INTC1START + 30) /**< Async EMIF       */
+#define   CSL_INTC_EVENTID_VLQ           (_CSL_INTC_EVENTID__INTC1START + 31) /**< VLYNQ            */
+#define   CSL_INTC_EVENTID_TIMER0INT12   (_CSL_INTC_EVENTID__INTC1START + 32) /**< Timer 0 - TINT12 */
+#define   CSL_INTC_EVENTID_TIMER0INT34   (_CSL_INTC_EVENTID__INTC1START + 33) /**< Timer 0 - TINT34 */
+#define   CSL_INTC_EVENTID_TIMER1INT12   (_CSL_INTC_EVENTID__INTC1START + 34) /**< Timer 1 - TINT12 */
+#define   CSL_INTC_EVENTID_TIMER1INT34   (_CSL_INTC_EVENTID__INTC1START + 35) /**< Timer 2 - TINT34 */
+#define   CSL_INTC_EVENTID_PWM0          (_CSL_INTC_EVENTID__INTC1START + 36) /**< PWM0             */
+#define   CSL_INTC_EVENTID_PWM1          (_CSL_INTC_EVENTID__INTC1START + 37) /**< PWM1             */
+#define   CSL_INTC_EVENTID_PWM2          (_CSL_INTC_EVENTID__INTC1START + 38) /**< PWM2             */
+#define   CSL_INTC_EVENTID_I2C           (_CSL_INTC_EVENTID__INTC1START + 39) /**< I2C              */
+#define   CSL_INTC_EVENTID_UART0         (_CSL_INTC_EVENTID__INTC1START + 40) /**< UART0            */
+#define   CSL_INTC_EVENTID_UART1         (_CSL_INTC_EVENTID__INTC1START + 41) /**< UART1            */
+#define   CSL_INTC_EVENTID_UART2         (_CSL_INTC_EVENTID__INTC1START + 42) /**< UART2            */
+#define   CSL_INTC_EVENTID_SPI0          (_CSL_INTC_EVENTID__INTC1START + 43) /**< SPI              */
+#define   CSL_INTC_EVENTID_SPI1          (_CSL_INTC_EVENTID__INTC1START + 44) /**< SPI              */
+#define   CSL_INTC_EVENTID_WDT           (_CSL_INTC_EVENTID__INTC1START + 45) /**< Timer 3 - TINT12 */
+#define   CSL_INTC_EVENTID_DSP0          (_CSL_INTC_EVENTID__INTC1START + 46) /**< DSP Controller   */
+#define   CSL_INTC_EVENTID_DSP1          (_CSL_INTC_EVENTID__INTC1START + 47) /**< DSP Controller   */
+#define   CSL_INTC_EVENTID_GPIO0         (_CSL_INTC_EVENTID__INTC1START + 48) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO1         (_CSL_INTC_EVENTID__INTC1START + 49) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO2         (_CSL_INTC_EVENTID__INTC1START + 50) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO3         (_CSL_INTC_EVENTID__INTC1START + 51) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO4         (_CSL_INTC_EVENTID__INTC1START + 52) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO5         (_CSL_INTC_EVENTID__INTC1START + 53) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO6         (_CSL_INTC_EVENTID__INTC1START + 54) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIO7         (_CSL_INTC_EVENTID__INTC1START + 55) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIOBNK0      (_CSL_INTC_EVENTID__INTC1START + 56) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIOBNK1      (_CSL_INTC_EVENTID__INTC1START + 57) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIOBNK2      (_CSL_INTC_EVENTID__INTC1START + 58) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIOBNK3      (_CSL_INTC_EVENTID__INTC1START + 59) /**< GPIO             */
+#define   CSL_INTC_EVENTID_GPIOBNK4      (_CSL_INTC_EVENTID__INTC1START + 60) /**< GPIO             */
+#define   CSL_INTC_EVENTID_COMMTX        (_CSL_INTC_EVENTID__INTC1START + 61) /**< ARMSS            */
+#define   CSL_INTC_EVENTID_COMMRX        (_CSL_INTC_EVENTID__INTC1START + 62) /**< ARMSS            */
+#define   CSL_INTC_EVENTID_EMU           (_CSL_INTC_EVENTID__INTC1START + 63) /**< E2ICE            */
+
+#define   _CSL_INTC_EVENTID__INTC1END    (_CSL_INTC_EVENTID__INTC1START + _CSL_INTC_EVENTID__INTC1CNT - 1)
+
+
+#define    _CSL_INTC_EVENTID__INTC0START (_CSL_INTC_EVENTID__INTC1END + 1)
+
+#define    CSL_INTC_EVENTID_RESET        (_CSL_INTC_EVENTID__INTC0START + 0)  /**< the RESET exception vector   */
+#define    CSL_INTC_EVENTID_UNDEF        (_CSL_INTC_EVENTID__INTC0START + 1)  /**< the UNDEF exception vector   */
+#define    CSL_INTC_EVENTID_SWI          (_CSL_INTC_EVENTID__INTC0START + 2)  /**< the SWI exception vector     */
+#define    CSL_INTC_EVENTID_PREABT       (_CSL_INTC_EVENTID__INTC0START + 3)  /**< the PREABT exception vector  */
+#define    CSL_INTC_EVENTID_DATABT       (_CSL_INTC_EVENTID__INTC0START + 4)  /**< the DATABT exception vector  */
+#define    CSL_INTC_EVENTID_IRQ          (_CSL_INTC_EVENTID__INTC0START + 6)  /**< the IRQ exception vector     */
+#define    CSL_INTC_EVENTID_FIQ          (_CSL_INTC_EVENTID__INTC0START + 7)  /**< the FIQ exception vector     */
+
+#define    _CSL_INTC_EVENTID__INTC0END   (_CSL_INTC_EVENTID__INTC0START + _CSL_INTC_EVENTID__INTC0CNT - 1)
+
+#define    CSL_INTC_EVENTID_INVALID      (-1)                                 /**< Invalid Event-ID */
+
+#endif
diff -Naur u-boot-1.1.6/board/davinci/timer.c u-boot-1.1.6_davinci/board/davinci/timer.c
--- u-boot-1.1.6/board/davinci/timer.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.6_davinci/board/davinci/timer.c	2006-11-27 15:36:12.000000000 +0100
@@ -0,0 +1,198 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ Modifications:
+ ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+
+#include <common.h>
+#include <arm926ejs.h>
+
+#include "soc.h"
+#include "timer.h"
+
+static ulong timestamp;
+static ulong lastdec;
+
+/* Use Timer 3&4 (Timer 2) */
+#define TIMER_BASE_ADDR	CSL_TMR_1_REGS
+
+#define TIMER_LOAD_VAL 0xffffffff
+
+davinci_timer_reg    *davinci_timer = (davinci_timer_reg *) TIMER_BASE_ADDR;
+
+/* Timer Initialize */
+void timer_init (void)
+{
+        /* disable Timer 1 & 2 timers */
+        davinci_timer->tcr = 0;
+
+        /* Set timers to unchained dual 32 bit timers, Unreset timer34 */
+        davinci_timer->tgcr = 0x0;
+        davinci_timer->tgcr = 0x6;
+
+        /* Program the timer12 counter register - set the prd12 for right count */
+        davinci_timer->tim34 = 0;
+
+        /* The timer is programmed to expire after 0xFFFFFFFF ticks */
+        davinci_timer->prd34 = 0xFFFFFFFF;
+
+        /* Enable timer34 */
+        davinci_timer->tcr = (0x80 << 16); /* Timer34 continously enabled, Timer12 disabled */
+}
+
+/* c+p from cpu/arm926ejs/omap/timer.c */ 
+
+/*
+ * timer without interrupts
+ */
+
+void reset_timer (void)
+{
+	reset_timer_masked ();
+}
+
+ulong get_timer (ulong base)
+{
+	return get_timer_masked () - base;
+}
+
+void set_timer (ulong t)
+{
+	timestamp = t;
+}
+
+/* delay x useconds AND perserve advance timstamp value */
+void udelay (unsigned long usec)
+{
+	ulong tmo, tmp;
+
+	if(usec >= 1000){		/* if "big" number, spread normalization to seconds */
+		tmo = usec / 1000;	/* start to normalize for usec to ticks per sec */
+		tmo *= CFG_HZ;		/* find number of "ticks" to wait to achieve target */
+		tmo /= 1000;		/* finish normalize. */
+	}else{				/* else small number, don't kill it prior to HZ multiply */
+		tmo = usec * CFG_HZ;
+		tmo /= (1000*1000);
+	}
+
+	tmp = get_timer (0);		/* get current timestamp */
+	if( (tmo + tmp + 1) < tmp )	/* if setting this fordward will roll time stamp */
+		reset_timer_masked ();	/* reset "advancing" timestamp to 0, set lastdec value */
+	else
+		tmo += tmp;		/* else, set advancing stamp wake up time */
+
+	while (get_timer_masked () < tmo)/* loop till event */
+		/*NOP*/;
+}
+
+void reset_timer_masked (void)
+{
+	/* reset time */
+	lastdec = READ_TIMER;  /* capure current decrementer value time */
+	timestamp = 0;	       /* start "advancing" time stamp from 0 */
+}
+
+ulong get_timer_masked (void)
+{
+	ulong now = READ_TIMER;		/* current tick value */
+
+	if (lastdec >= now) {		/* normal mode (non roll) */
+		/* normal mode */
+		timestamp += lastdec - now; /* move stamp fordward with absoulte diff ticks */
+	} else {			/* we have overflow of the count down timer */
+		/* nts = ts + ld + (TLV - now)
+		 * ts=old stamp, ld=time that passed before passing through -1
+		 * (TLV-now) amount of time after passing though -1
+		 * nts = new "advancing time stamp"...it could also roll and cause problems.
+		 */
+		timestamp += lastdec + TIMER_LOAD_VAL - now;
+	}
+	lastdec = now;
+
+	return timestamp;
+}
+
+/* waits specified delay value and resets timestamp */
+void udelay_masked (unsigned long usec)
+{
+	ulong tmo;
+	ulong endtime;
+	signed long diff;
+
+	if (usec >= 1000) {		/* if "big" number, spread normalization to seconds */
+		tmo = usec / 1000;	/* start to normalize for usec to ticks per sec */
+		tmo *= CFG_HZ;		/* find number of "ticks" to wait to achieve target */
+		tmo /= 1000;		/* finish normalize. */
+	} else {			/* else small number, don't kill it prior to HZ multiply */
+		tmo = usec * CFG_HZ;
+		tmo /= (1000*1000);
+	}
+
+	endtime = get_timer_masked () + tmo;
+
+	do {
+		ulong now = get_timer_masked ();
+		diff = endtime - now;
+	} while (diff >= 0);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+ulong get_tbclk (void)
+{
+	ulong tbclk;
+
+	tbclk = CFG_HZ;
+	return tbclk;
+}
+
+/************************************************************
+********************** Reset Processor **********************
+************************************************************/
+#define WDT_BASE_ADDR          CSL_WDT_1_REGS
+
+
+void reset_processor(void)
+{
+        davinci_timer_reg *davinci_wdt = (davinci_timer_reg *) WDT_BASE_ADDR;
+        davinci_wdt->tgcr   = 0x00000008;
+        davinci_wdt->tgcr  |= 0x00000003;
+        davinci_wdt->tim12  = 0x00000000;
+        davinci_wdt->tim34  = 0x00000000;
+        davinci_wdt->prd12  = 0x00000000;
+        davinci_wdt->prd34  = 0x00000000;
+        davinci_wdt->tcr   |= 0x00000040;
+        davinci_wdt->wdtcr |= 0x00004000;
+        davinci_wdt->wdtcr  = 0xA5C64000;
+        davinci_wdt->wdtcr  = 0xDA7E4000;
+}
diff -Naur u-boot-1.1.6/board/davinci/timer.h u-boot-1.1.6_davinci/board/davinci/timer.h
--- u-boot-1.1.6/board/davinci/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.6_davinci/board/davinci/timer.h	2006-11-27 13:45:30.000000000 +0100
@@ -0,0 +1,51 @@
+/*
+ *
+ *  Copyright (C) 2004 Texas Instruments.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ * Modifications:
+ * ver. 1.0: Oct 2005, Swaminathan S
+ *
+ */
+#ifndef __TIMER_H__
+#define __TIMER_H__
+
+typedef volatile struct davinci_timer_reg_t
+{
+    unsigned int pid12;         /* 0x0 */
+    unsigned int emumgt_clksped;/* 0x4 */
+    unsigned int gpint_en;      /* 0x8 */
+    unsigned int gpdir_dat;     /* 0xC */
+    unsigned int tim12;         /* 0x10 */
+    unsigned int tim34;         /* 0x14 */
+    unsigned int prd12;         /* 0x18 */
+    unsigned int prd34;         /* 0x1C */
+    unsigned int tcr;           /* 0x20 */
+    unsigned int tgcr;          /* 0x24 */
+    unsigned int wdtcr;         /* 0x28 */
+    unsigned int tlgc;          /* 0x2C */
+    unsigned int tlmr;          /* 0x30 */
+} davinci_timer_reg;
+
+#endif  /* __TIMER_H__ */
+
diff -Naur u-boot-1.1.6/board/davinci/types.h u-boot-1.1.6_davinci/board/davinci/types.h
--- u-boot-1.1.6/board/davinci/types.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.6_davinci/board/davinci/types.h	2006-11-27 16:14:50.000000000 +0100
@@ -0,0 +1,48 @@
+/*
+ *
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ */
+#ifndef _TYPESH_
+#define _TYPESH_
+
+typedef unsigned long 	ULONG;
+typedef unsigned short 	USHORT;
+typedef unsigned long   BOOL;
+typedef unsigned int	WORD;
+typedef char            CHAR;
+typedef unsigned char   BYTE, *LPBYTE, UCHAR, *PUCHAR, PBYTE;
+
+#define FALSE           0
+#define TRUE            1
+
+#ifndef NULL 
+#define NULL		((void *)0)
+#endif  
+
+typedef unsigned short int Hwd;
+typedef volatile unsigned short int vHwd;
+typedef unsigned short int *  Hwdptr;
+typedef volatile unsigned short int * vHwdptr;
+//typedef volatile unsigned int * vHwdptr;
+
+
+#endif
+
diff -Naur u-boot-1.1.6/board/davinci/u-boot.lds u-boot-1.1.6_davinci/board/davinci/u-boot.lds
--- u-boot-1.1.6/board/davinci/u-boot.lds	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.6_davinci/board/davinci/u-boot.lds	2006-11-27 13:45:30.000000000 +0100
@@ -0,0 +1,51 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+	. = ALIGN(4);
+	.text	:
+	{
+	  cpu/arm926ejs/start.o	(.text)
+	  *(.text)
+	}
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+	. = ALIGN(4);
+	.data : { *(.data) }
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -Naur u-boot-1.1.6/cpu/arm926ejs/config.mk u-boot-1.1.6_davinci/cpu/arm926ejs/config.mk
--- u-boot-1.1.6/cpu/arm926ejs/config.mk	2006-11-02 15:15:01.000000000 +0100
+++ u-boot-1.1.6_davinci/cpu/arm926ejs/config.mk	2006-11-27 14:34:48.000000000 +0100
@@ -24,7 +24,7 @@
 PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8 \
 	-msoft-float
 
-PLATFORM_CPPFLAGS += -march=armv4
+PLATFORM_CPPFLAGS += -march=armv4  -mno-thumb-interwork
 # =========================================================================
 #
 # Supply options according to compiler version
diff -Naur u-boot-1.1.6/drivers/Makefile u-boot-1.1.6_davinci/drivers/Makefile
--- u-boot-1.1.6/drivers/Makefile	2006-11-02 15:15:01.000000000 +0100
+++ u-boot-1.1.6_davinci/drivers/Makefile	2006-11-27 14:09:38.000000000 +0100
@@ -51,7 +51,8 @@
 	  ks8695eth.o \
 	  pxa_pcmcia.o mpc8xx_pcmcia.o tqm8xx_pcmcia.o	\
 	  rpx_pcmcia.o \
-	  fsl_i2c.o
+	  fsl_i2c.o \
+	  davinci_i2c.o
 
 SRCS	:= $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS))
diff -Naur u-boot-1.1.6/drivers/cfi_flash.c u-boot-1.1.6_davinci/drivers/cfi_flash.c
--- u-boot-1.1.6/drivers/cfi_flash.c	2006-11-02 15:15:01.000000000 +0100
+++ u-boot-1.1.6_davinci/drivers/cfi_flash.c	2007-03-08 14:16:18.000000000 +0100
@@ -42,7 +42,7 @@
  */
 
 /* The DEBUG define must be before common to enable debugging */
-/* #define DEBUG	*/
+/* #define DEBUG */
 
 #include <common.h>
 #include <asm/processor.h>
diff -Naur u-boot-1.1.6/drivers/davinci_i2c.c u-boot-1.1.6_davinci/drivers/davinci_i2c.c
--- u-boot-1.1.6/drivers/davinci_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.6_davinci/drivers/davinci_i2c.c	2006-11-27 13:45:30.000000000 +0100
@@ -0,0 +1,296 @@
+/*
+ * Basic I2C functions
+ *
+ * Copyright (c) 2004 Texas Instruments
+ *
+ * This package is free software;  you can redistribute it and/or
+ * modify it under the terms of the license found in the file
+ * named COPYING that should have accompanied this file.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * Author: Jian Zhang jzhang@ti.com, Texas Instruments
+ *
+ * Copyright (c) 2003 Wolfgang Denk, wd@denx.de
+ * Rewritten to fit into the current U-Boot framework
+ *
+ * Adapted for DaVinci I2C, swami.iyer@ti.com
+ *
+ */
+
+#include <common.h>
+
+#ifdef CONFIG_DRIVER_DAVINCI_I2C
+
+#include "davinci_i2c.h"
+#include <i2c.h>
+#include <asm/io.h>
+
+#define inw(a) __raw_readw(a)
+#define outw(a,v) __raw_writew(a,v)
+
+static void wait_for_bb (void);
+static u16 wait_for_pin (void);
+void flush_fifo(void);
+
+void i2c_init (int speed, int slaveadd)
+{
+	u16 scl;
+
+	if (inw (I2C_CON) & I2C_CON_EN) {
+		outw (0, I2C_CON);
+		udelay (50000);
+	}
+
+	outw (26, I2C_PSC);
+	outw (30, I2C_SCLL);
+	outw (10, I2C_SCLH);
+	/* own address */
+	outw (slaveadd, I2C_OA);
+	outw (0, I2C_CNT);
+	/* have to enable intrrupts or DaVinci i2c module doesn't work */
+	outw (I2C_IE_SCD_IE | I2C_IE_XRDY_IE | I2C_IE_RRDY_IE | I2C_IE_ARDY_IE |
+	      I2C_IE_NACK_IE | I2C_IE_AL_IE, I2C_IE);
+	outw (I2C_CON_EN, I2C_CON);
+	udelay (1000);
+
+}
+
+static int i2c_read_byte (u8 devaddr, u8 regoffset, u8 * value)
+{
+	int i2c_error = 0;
+	u16 status;
+
+	/* wait until bus not busy */
+	wait_for_bb ();
+
+	/* one byte only */
+	outw (1, I2C_CNT);
+	/* set slave address */
+	outw (devaddr, I2C_SA);
+	/* no stop bit needed here */
+	outw (I2C_CON_EN | I2C_CON_MST | I2C_CON_STT | I2C_CON_TRX, I2C_CON);
+
+	status = wait_for_pin ();
+
+
+	if (!i2c_error) {
+		/* free bus, otherwise we can't use a combined transction */
+		outw (0, I2C_CON);
+
+		wait_for_bb ();
+		/* set slave address */
+		outw (devaddr, I2C_SA);
+		/* read one byte from slave */
+		outw (1, I2C_CNT);
+		/* need stop bit here */
+		outw (I2C_CON_EN | I2C_CON_MST | I2C_CON_STT | I2C_CON_STP,
+		      I2C_CON);
+
+		status = wait_for_pin ();
+		if (status & I2C_STAT_RRDY) {
+			*value = inw (I2C_DRR);
+			udelay (20000);
+		} else {
+			i2c_error = 1;
+		}
+
+		if (!i2c_error) {
+			outw (I2C_CON_EN, I2C_CON);
+		}
+	}
+	flush_fifo();
+	outw (0xFFFF, I2C_STAT);
+	outw (0, I2C_CNT);
+	return i2c_error;
+}
+
+static int i2c_write_byte (u8 devaddr, u8 regoffset, u8 value)
+{
+	int i2c_error = 0;
+	u16 status, stat;
+	u16 temp;
+
+	/* wait until bus not busy */
+	wait_for_bb ();
+
+	/* two bytes */
+	outw (2, I2C_CNT);
+	/* set slave address */
+	outw (devaddr, I2C_SA);
+	/* stop bit needed here */
+	outw (I2C_CON_EN | I2C_CON_MST | I2C_CON_STT | I2C_CON_TRX |
+	      I2C_CON_STP, I2C_CON);
+
+	/* wait until state change */
+	status = wait_for_pin ();
+
+	if (status & I2C_STAT_XRDY) {
+		/* send out two bytes */
+		outw (value, I2C_DXR);
+		/* must have enough delay to allow BB bit to go low */
+		udelay (50000);
+		if (inw (I2C_STAT) & I2C_STAT_NACK) {
+			i2c_error = 1;
+		}
+	} else {
+		i2c_error = 1;
+	}
+
+	if (!i2c_error) {
+		outw (I2C_CON_EN, I2C_CON);
+		do {
+			temp = inw(I2C_STAT) && I2C_STAT_SCD;
+		} while (!temp);	
+	}
+	flush_fifo();
+	outw (0xFFFF, I2C_STAT);
+	outw (0, I2C_CNT);
+	return i2c_error;
+}
+
+void flush_fifo(void)
+{	u16 stat;
+
+	/* note: if you try and read data when its not there or ready
+	 * you get a bus error
+	 */
+	while(1){
+		stat = inw(I2C_STAT);
+		if(stat == I2C_STAT_RRDY){
+			inw(I2C_DRR);
+			outw(I2C_STAT_RRDY,I2C_STAT);
+			udelay(1000);
+		}else
+			break;
+	}
+}
+
+int i2c_probe (uchar chip)
+{
+	int res = 1; /* default = fail */
+
+	if (chip == inw (I2C_OA)) {
+		return res;
+	}
+
+	/* wait until bus not busy */
+	wait_for_bb ();
+
+	/* try to read one byte */
+	outw (1, I2C_CNT);
+	/* set slave address */
+	outw (chip, I2C_SA);
+	/* stop bit needed here */
+	outw (I2C_CON_EN | I2C_CON_MST | I2C_CON_STT | I2C_CON_STP, I2C_CON);
+	/* enough delay for the NACK bit set */
+	udelay (50000);
+
+	if (!(inw (I2C_STAT) & I2C_STAT_NACK)) {
+		res = 0;      /* success case */
+		flush_fifo();
+		outw(0xFFFF, I2C_STAT);
+	} else {
+		outw(0xFFFF, I2C_STAT);	 /* failue, clear sources*/
+		outw (inw (I2C_CON) | I2C_CON_STP, I2C_CON); /* finish up xfer */
+		udelay(20000);
+		wait_for_bb ();
+	}
+	flush_fifo();
+	outw (0, I2C_CNT); /* don't allow any more data in...we don't want it.*/
+	outw(0xFFFF, I2C_STAT);
+	return res;
+}
+
+int i2c_read (uchar chip, uint addr, int alen, uchar * buffer, int len)
+{
+	int i;
+
+	if (alen > 1) {
+		printf ("I2C read: addr len %d not supported\n", alen);
+		return 1;
+	}
+
+	if (addr + len > 256) {
+		printf ("I2C read: address out of range\n");
+		return 1;
+	}
+
+	for (i = 0; i < len; i++) {
+		if (i2c_read_byte (chip, addr + i, &buffer[i])) {
+			printf ("I2C read: I/O error\n");
+			i2c_init (CFG_I2C_SPEED, CFG_I2C_SLAVE);
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+int i2c_write (uchar chip, uint addr, int alen, uchar * buffer, int len)
+{
+	int i;
+
+	if (alen > 1) {
+		printf ("I2C read: addr len %d not supported\n", alen);
+		return 1;
+	}
+
+	if (addr + len > 256) {
+		printf ("I2C read: address out of range\n");
+		return 1;
+	}
+
+	for (i = 0; i < len; i++) {
+		if (i2c_write_byte (chip, addr + i, buffer[i])) {
+			printf ("I2C read: I/O error\n");
+			i2c_init (CFG_I2C_SPEED, CFG_I2C_SLAVE);
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static void wait_for_bb (void)
+{
+	int timeout = 0;
+	u16 stat;
+
+	outw(0xFFFF, I2C_STAT);	 /* clear current interrupts...*/
+	while ((stat = inw (I2C_STAT) & I2C_STAT_BB) && timeout--) {
+		outw (stat, I2C_STAT);
+		udelay (50000);
+	}
+
+	if (timeout <= 0) {
+		/*printf ("timed out in wait_for_bb: I2C_STAT=%x\n",
+			inw (I2C_STAT));*/
+	}
+	outw(0xFFFF, I2C_STAT);	 /* clear delayed stuff*/
+}
+
+static u16 wait_for_pin (void)
+{
+	u16 status;
+	int timeout = 10;
+
+	do {
+		udelay (1000);
+		status = inw (I2C_STAT);
+	} while (  !(status &
+		   (I2C_STAT_ROVR | I2C_STAT_XUDF | I2C_STAT_XRDY |
+		    I2C_STAT_RRDY | I2C_STAT_ARDY | I2C_STAT_NACK |
+		    I2C_STAT_AL   | I2C_STAT_SCD)) && timeout--);
+
+	if (timeout <= 0) {
+		printf ("timed out in wait_for_pin: I2C_STAT=%x\n",
+			inw (I2C_STAT));
+			outw(0xFFFF, I2C_STAT);
+}
+	return status;
+}
+
+#endif /* CONFIG_DRIVER_DAVINCI_I2C */
diff -Naur u-boot-1.1.6/drivers/davinci_i2c.h u-boot-1.1.6_davinci/drivers/davinci_i2c.h
--- u-boot-1.1.6/drivers/davinci_i2c.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.6_davinci/drivers/davinci_i2c.h	2006-11-27 13:45:30.000000000 +0100
@@ -0,0 +1,87 @@
+/*
+ * (C) Copyright 2004
+ * Texas Instruments, <www.ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _DAVINCI_I2C_H_
+#define _DAVINCI_I2C_H_
+
+#define I2C_BASE                0x01C21000 
+
+#define	I2C_OA			(I2C_BASE + 0x00)
+#define I2C_IE                  (I2C_BASE + 0x04)
+#define I2C_STAT                (I2C_BASE + 0x08)
+#define I2C_SCLL                (I2C_BASE + 0x0c)
+#define I2C_SCLH                (I2C_BASE + 0x10)
+#define I2C_CNT                 (I2C_BASE + 0x14)
+#define I2C_DRR                 (I2C_BASE + 0x18)
+#define I2C_SA                  (I2C_BASE + 0x1c)
+#define I2C_DXR                 (I2C_BASE + 0x20)
+#define I2C_CON                 (I2C_BASE + 0x24)
+#define I2C_IV                  (I2C_BASE + 0x28)
+#define I2C_PSC                 (I2C_BASE + 0x30)
+
+/* I2C masks */
+
+/* I2C Interrupt Enable Register (I2C_IE): */
+#define I2C_IE_SCD_IE   (1 << 5)        /* Stop condition detect interrupt enable */
+#define I2C_IE_XRDY_IE  (1 << 4)        /* Transmit data ready interrupt enable */
+#define I2C_IE_RRDY_IE  (1 << 3)        /* Receive data ready interrupt enable */
+#define I2C_IE_ARDY_IE  (1 << 2)        /* Register access ready interrupt enable */
+#define I2C_IE_NACK_IE  (1 << 1)        /* No acknowledgment interrupt enable */
+#define I2C_IE_AL_IE    (1 << 0)        /* Arbitration lost interrupt enable */
+
+/* I2C Status Register (I2C_STAT): */
+
+#define I2C_STAT_BB     (1 << 12)       /* Bus busy */
+#define I2C_STAT_ROVR   (1 << 11)       /* Receive overrun */
+#define I2C_STAT_XUDF   (1 << 10)       /* Transmit underflow */
+#define I2C_STAT_AAS    (1 << 9)        /* Address as slave */
+#define I2C_STAT_SCD    (1 << 5)        /* Stop condition detect */
+#define I2C_STAT_XRDY   (1 << 4)        /* Transmit data ready */
+#define I2C_STAT_RRDY   (1 << 3)        /* Receive data ready */
+#define I2C_STAT_ARDY   (1 << 2)        /* Register access ready */
+#define I2C_STAT_NACK   (1 << 1)        /* No acknowledgment interrupt enable */
+#define I2C_STAT_AL     (1 << 0)        /* Arbitration lost interrupt enable */
+
+
+/* I2C Interrupt Code Register (I2C_INTCODE): */
+
+#define I2C_INTCODE_MASK        7
+#define I2C_INTCODE_NONE        0
+#define I2C_INTCODE_AL          1       /* Arbitration lost */
+#define I2C_INTCODE_NAK         2       /* No acknowledgement/general call */
+#define I2C_INTCODE_ARDY        3       /* Register access ready */
+#define I2C_INTCODE_RRDY        4       /* Rcv data ready */
+#define I2C_INTCODE_XRDY        5       /* Xmit data ready */
+#define I2C_INTCODE_SCD         6       /* Stop condition detect */
+
+
+/* I2C Configuration Register (I2C_CON): */
+
+#define I2C_CON_EN      (1 << 5)       /* I2C module enable */
+#define I2C_CON_STB     (1 << 4)       /* Start byte mode (master mode only) */
+#define I2C_CON_MST     (1 << 10)      /* Master/slave mode */
+#define I2C_CON_TRX     (1 << 9)       /* Transmitter/receiver mode (master mode only) */
+#define I2C_CON_XA      (1 << 8)       /* Expand address */
+#define I2C_CON_STP     (1 << 11)      /* Stop condition (master mode only) */
+#define I2C_CON_STT     (1 << 13)      /* Start condition (master mode only) */
+
+#endif
diff -Naur u-boot-1.1.6/include/configs/davinci.h u-boot-1.1.6_davinci/include/configs/davinci.h
--- u-boot-1.1.6/include/configs/davinci.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-1.1.6_davinci/include/configs/davinci.h	2007-03-08 14:40:07.000000000 +0100
@@ -0,0 +1,228 @@
+/*
+ * (C) Copyright 2003
+ * Texas Instruments.
+ * Swaminathan S <swami.iyer@ti.com>
+ * Configuation settings for the TI DaVinci EVM board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/* Chip Configurations */
+/*============================================================================*/
+#define CFG_DAVINCI
+#define CONFIG_ARM926EJS	/* This is an arm926ejs CPU core  	  */
+#define CONFIG_SYS_CLK_FREQ	229500000	/* Arm Clock frequency    */
+#define CFG_TIMERBASE		0x01C21400	/* use timer 0 		  */
+#define CFG_HZ			27000000	/* Timer Input clock freq */	
+/*============================================================================*/
+
+/*
+ * Flash Boot info
+*/
+/*============================================================================*/
+#define CFG_ENV_IS_IN_FLASH 	1		/* U-Boot env in NOR Flash   */
+
+#ifndef CFG_ENV_IS_IN_FLASH
+#define CFG_ENV_IS_IN_NAND 	1               /* U-Boot env in NAND Flash  */
+#define CFG_ENV_SECT_SIZE	512		/* Env sector Size */
+#define CFG_ENV_SIZE		(16 * 1024)
+#else
+#define CONFIG_INITRD_TAG  	  1
+#define CFG_ENV_SECT_SIZE	CFG_FLASH_SECT_SZ	/* Env sector Size */
+#define CFG_ENV_SIZE		CFG_FLASH_SECT_SZ
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x20000)
+#endif
+
+
+/*
+ * NOR Flash Info 
+ */
+/*============================================================================*/
+#define CONFIG_CS0_BOOT				/* Boot from Flash 	     */
+
+/*
+CFI Flash Configuration
+*/
+#define CFG_FLASH_CFI				/* Flash is CFI compliant */
+#define CFG_FLASH_CFI_DRIVER			/* use the CFI driver */ 
+#define CFG_MAX_FLASH_BANKS		(1) 	/* max number of chips */ 
+#define CFG_MAX_FLASH_SECT		(512)	/* max number of sectors */
+#define CFG_FLASH_USE_BUFFER_WRITE 	1	/* Use buffered writes (~10x faster) */
+/* #define CFG_FLASH_PROTECTION		1	*//* Use hardware sector protection */
+#define CFG_FLASH_ERASE_TOUT		(20*CFG_HZ)	/* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT		(20*CFG_HZ)	/* Timeout for Flash Write */
+
+#define CFG_FLASH_SECT_SZ	0x20000		/* only used for env  */
+		
+#ifdef CONFIG_CS0_BOOT
+#define PHYS_FLASH_1		0x02000000	/* CS0 Base address 	 */
+#endif
+
+#ifdef CONFIG_CS3_BOOT
+#define PHYS_FLASH_1		0x00000000	/* Need to update CHECK  */
+#endif
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1 	/* Flash Base for U-Boot */
+#define CONFIG_ENV_OVERWRITE			/* allow env overwrie 	 */
+
+/*============================================================================*/
+
+/*
+ * Memory Info 
+ */
+/*============================================================================*/
+#define CFG_MALLOC_LEN		(0x10000 + 128*1024)  /* malloc () len */
+#define CFG_GBL_DATA_SIZE	128		/* reserved for initial data */
+#define CFG_MEMTEST_START	0x82000000	/* memtest start address  */
+#define CFG_MEMTEST_END		0x90000000	/* 16MB RAM test   	  */
+#define CONFIG_NR_DRAM_BANKS	1		/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x80000000	/* DDR Start 		  */
+#define PHYS_SDRAM_1_SIZE	0x10000000	/* DDR size 256MB 	  */
+#define CONFIG_STACKSIZE	(256*1024)	/* regular stack	  */
+/*============================================================================*/
+
+/*
+ * Serial Driver info
+ */
+/*============================================================================*/
+#define CFG_NS16550			/* Include NS16550 as serial driver */
+#define CFG_NS16550_SERIAL
+#define CFG_NS16550_REG_SIZE 	4		/* NS16550 register size */
+#define CFG_NS16550_COM1 	0X01C20000	/* Base address of UART0  */
+#define CFG_NS16550_CLK 	27000000	/* Input clock to NS16550 */
+#define CONFIG_CONS_INDEX	1		/* use UART0 for console  */
+#define CONFIG_BAUDRATE		115200		/* Default baud rate      */
+#define CFG_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+/*============================================================================*/
+
+/* U-Boot Configurations */
+/*============================================================================*/
+/*
+ * If we are developing, we might want to start armboot from ram
+ * so we MUST NOT initialize critical regs like mem-timing ...
+ */
+
+/* for Ram load version do not do low level init and do not relocate */
+#undef  CONFIG_INIT_CRITICAL
+#define CONFIG_SKIP_LOWLEVEL_INIT
+/* #define CONFIG_SKIP_RELOCATE_UBOOT not needed, tested by boot code */ 
+
+#undef 	CONFIG_USE_IRQ				/* we don't need IRQ/FIQ */
+#define CONFIG_MISC_INIT_R
+#define CONFIG_BOOTDELAY	  3     	/* Boot delay before OS boot*/
+#define CONFIG_BOOTFILE		"uImage"	/* file to load */
+#define CFG_LONGHELP				/* undef to save memory     */
+#define CFG_PROMPT	"DaVinci EVM # "	/* Monitor Command Prompt   */
+#define CFG_CBSIZE	1024			/* Console I/O Buffer Size  */
+#define CFG_PBSIZE	(CFG_CBSIZE+sizeof(CFG_PROMPT)+16) /* Print buffer sz */
+#define CFG_MAXARGS	16		/* max number of command args   */
+#define CFG_BARGSIZE	CFG_CBSIZE	/* Boot Argument Buffer Size    */
+#undef	CFG_CLKS_IN_HZ			/* Clock info are in HZ */
+#define CFG_LOAD_ADDR	0x80700000	/* default load address of Linux */
+
+/*
+ *  I2C Configuration 
+ */
+#define CONFIG_HARD_I2C
+#define CFG_I2C_SPEED 100000
+#define CFG_I2C_SLAVE 10
+#define CONFIG_DRIVER_DAVINCI_I2C
+
+/* macro to read the 32 bit timer Timer 2 */
+#define READ_TIMER (0xFFFFFFFF - (*(volatile ulong *)(CFG_TIMERBASE + 0x14)))
+
+/* Linux Information */
+
+#define LINUX_BOOT_PARAM_ADDR	0x80000100	/* Set the Boot location at the
+						 * end of DDR
+						 */
+#define CONFIG_CMDLINE_TAG	  1	/* enable passing of ATAGs  */
+#define CONFIG_SETUP_MEMORY_TAGS  1
+#define CONFIG_BOOTARGS		"mem=120M console=ttyS0,115200n8 root=/dev/ram0 rw init=/bin/ash initrd=0x82000000,4M"
+
+#define CONFIG_BOOTCOMMAND	"dhcp;tftpboot 0x82000000 initrd.image;setenv addip setenv bootargs \$(bootargs) ip=\$(ipaddr):\$(serverip):\$(gatewayip):\$(netmask):\$(hostname)::off eth=\$(ethaddr) video=dm64xxfb:output=\$(videostd);run addip;bootm 0x80700000"
+
+/*============================================================================*/
+
+/*
+ * Network & Ethernet Configuration
+ */
+/*============================================================================*/
+#define CONFIG_DRIVER_TI_EMAC
+
+#define CONFIG_BOOTP_MASK	(CONFIG_BOOTP_DEFAULT | CONFIG_BOOTP_DNS | CONFIG_BOOTP_DNS2 | CONFIG_BOOTP_SEND_HOSTNAME)
+#define CONFIG_NET_RETRY_COUNT  10
+/*============================================================================*/
+
+/*============================================================================*/
+
+/* NAND Flash stuff */
+/*============================================================================*/
+#ifdef CFG_ENV_IS_IN_NAND
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_DHCP | CFG_CMD_NAND)
+#define CONFIG_SKIP_LOWLEVEL_INIT       /* needed for booting from NAND as UBL
+					 * bootloads u-boot.  The low level init
+					 * is configured by the UBL.
+					 */
+#define CFG_NAND_ADDR           0x02000000
+
+#define CFG_MAX_NAND_DEVICE     1	/* Max number of NAND devices */
+#define SECTORSIZE              512
+
+#define ADDR_COLUMN             1
+#define ADDR_PAGE               2
+#define ADDR_COLUMN_PAGE        3
+
+#define NAND_ChipID_UNKNOWN     0x00
+#define NAND_MAX_FLOORS         1
+#define NAND_MAX_CHIPS          1
+#define CFG_ENV_OFFSET	        0x100000        /* environment starts here  */
+
+#define WRITE_NAND_COMMAND(d, adr) do {*(volatile u8 *)0x02000010 = (u8)d;} while(0)
+#define WRITE_NAND_ADDRESS(d, adr) do {*(volatile u8 *)0x0200000A = (u8)d;} while(0)
+#define WRITE_NAND(d, adr) do {*(volatile u8 *)0x02000000 = (u8)d;} while(0)
+#define READ_NAND(adr) (*(volatile u8 *)0x02000000)
+#define NAND_WAIT_READY(nand) while (!((*(volatile u32 *)0x01E00064) & 1))
+
+#define NAND_NO_RB          1
+
+#define NAND_CTL_CLRALE(nandptr) do {} while(0)
+#define NAND_CTL_SETALE(nandptr) do {} while(0)
+#define NAND_CTL_CLRCLE(nandptr) do {} while(0)
+#define NAND_CTL_SETCLE(nandptr) do {} while(0)
+#define NAND_DISABLE_CE(nand) do {*(volatile u32 *)0x01E00060 &= ~0x01;} while(0)
+#define NAND_ENABLE_CE(nand) do {*(volatile u32 *)0x01E00060 |= 0x01;} while(0)
+#else
+#define CONFIG_COMMANDS		(CONFIG_CMD_DFL | CFG_CMD_PING | CFG_CMD_DHCP)
+#endif
+
+/* KGDB support */
+/*============================================================================*/
+#if (CONFIG_COMMANDS & CFG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	1	/* which serial port to use */
+#endif
+
+/* this must be included AFTER the definition of CONFIG_COMMANDS (if any) */
+#include <cmd_confdefs.h>
+
+#endif /* __CONFIG_H */
diff -Naur u-boot-1.1.6/include/flash.h u-boot-1.1.6_davinci/include/flash.h
--- u-boot-1.1.6/include/flash.h	2006-11-02 15:15:01.000000000 +0100
+++ u-boot-1.1.6_davinci/include/flash.h	2007-03-07 19:51:06.000000000 +0100
@@ -205,6 +205,8 @@
 #define AMD_ID_LV128U_3 0x22002200	/* 3rd ID word for AM29LV128M  at 0x3c */
 #define AMD_ID_LV256U_2 0x22122212	/* 2nd ID word for AM29LV256M  at 0x38 */
 #define AMD_ID_LV256U_3 0x22012201	/* 3rd ID word for AM29LV256M  at 0x3c */
+#define AMD_ID_GL256N_2 0x22222222	/*  */
+#define AMD_ID_GL256N_3 0x22012201	/* 3rd ID word for AM29LV256M  at 0x3c */
 #define AMD_ID_GL064M_2 0x22132213	/* 2nd ID word for S29GL064M-R6 */
 #define AMD_ID_GL064M_3 0x22012201	/* 3rd ID word for S29GL064M-R6 */
 #define AMD_ID_GL064MT_2 0x22102210	/* 2nd ID word for S29GL064M-R3 (top boot sector) */
@@ -287,6 +289,8 @@
 #define INTEL_ID_28F256P30T 0x88198819	/* 256M = 128K x 255 + 32k x 4 */
 #define INTEL_ID_28F256P30B 0x881C881C	/* 256M = 128K x 255 + 32k x 4 */
 
+#define INTEL_ID_28F128P30T 0x88188818	/* 128M = 128K x 255 + 32k x 4 */
+
 #define INTEL_ID_28F160S3   0x00D000D0	/*  16M = 512K x  32 (64kB x 32)	*/
 #define INTEL_ID_28F320S3   0x00D400D4	/*  32M = 512K x  64 (64kB x 64)	*/
 
@@ -411,6 +415,7 @@
 #define FLASH_28F64K3	0x00B4		/* Intel 28F64K3   (  64M)		*/
 #define FLASH_28F128K3	0x00B6		/* Intel 28F128K3  ( 128M = 8M x 16 )	*/
 #define FLASH_28F256K3	0x00B8		/* Intel 28F256K3  ( 256M = 16M x 16 )	*/
+#define FLASH_28F128P30T 0x00BA		/* Intel 28F128P30 ( 128M = 128K x 155 + 32k x 4 */
 
 #define FLASH_28F320J3A 0x00C0		/* INTEL 28F320J3A ( 32M = 128K x  32)	*/
 #define FLASH_28F640J3A 0x00C2		/* INTEL 28F640J3A ( 64M = 128K x  64)	*/
diff -Naur u-boot-1.1.6/include/linux/mtd/nand_ids.h u-boot-1.1.6_davinci/include/linux/mtd/nand_ids.h
--- u-boot-1.1.6/include/linux/mtd/nand_ids.h	2006-11-02 15:15:01.000000000 +0100
+++ u-boot-1.1.6_davinci/include/linux/mtd/nand_ids.h	2006-11-27 14:20:01.000000000 +0100
@@ -54,6 +54,7 @@
 	{"Samsung K9F5616Q0C",    NAND_MFR_SAMSUNG, 0x45, 25, 0, 2, 0x4000, 1},
 	{"Samsung K9K1216Q0C",    NAND_MFR_SAMSUNG, 0x46, 26, 0, 3, 0x4000, 1},
 	{"Samsung K9F1G08U0M",    NAND_MFR_SAMSUNG, 0xf1, 27, 0, 2, 0, 0},
+	{"Samsung K9K1208Q0C",    NAND_MFR_SAMSUNG, 0x36, 26, 0, 3, 0x4000, 0},
 	{NULL,}
 };
 
diff -Naur u-boot-1.1.6/lib_arm/board.c u-boot-1.1.6_davinci/lib_arm/board.c
--- u-boot-1.1.6/lib_arm/board.c	2006-11-02 15:15:01.000000000 +0100
+++ u-boot-1.1.6_davinci/lib_arm/board.c	2006-11-27 13:45:30.000000000 +0100
@@ -185,7 +185,6 @@
 }
 #endif /* CFG_NO_FLASH */
 
-
 /*
  * Breathe some life into the board...
  *
@@ -363,7 +362,15 @@
 	/* enable exceptions */
 	enable_interrupts ();
 
-	/* Perform network card initialisation if necessary */
+    /* Perform network card initialisation if necessary */
+
+#ifdef CONFIG_DRIVER_TI_EMAC
+extern void emac_set_mac_addr (const char *addr);
+	if (getenv ("ethaddr")) {
+		emac_set_mac_addr(gd->bd->bi_enetaddr);
+	}
+#endif
+	
 #ifdef CONFIG_DRIVER_CS8900
 	cs8900_get_enetaddr (gd->bd->bi_enetaddr);
 #endif
